/*
 * Copyright 2019-2021 coreLang contributors <https://mal-lang.org/coreLang/contributors.html>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "coreVulnerability.mal"
include "SoftwareVulnerability.mal"
include "HardwareVulnerability.mal"

category ComputeResources {

    asset Hardware
      user info: "Specifies the hardware on which applications can run."
    {
      | attemptUseVulnerability @hidden
        developer info: "Intermediate attack step to allow for defences."
        ->  useVulnerability

      & useVulnerability
        user info: "The attacker is able to use the connected vulnerabilities, usually as a result of obtaining physical access."
        ->  vulnerabilities.attemptAbuse

      | attemptGainFullAccess @hidden
        developer info: "Intermediate attack step to allow for defences."
        ->  fullAccess

      & fullAccess {C,I,A}
        user info: "Full access on a piece of hardware confers full access on the applications running on it and access to the hosted data."
        ->  sysExecutedApps.fullAccess,
            hostedData.attemptAccess

      | attemptSupplyChainAttack
        developer info: "Intermediate attack step to allow for the auditing defence."
        ->  supplyChainAttack

      & supplyChainAttack [VeryHardAndUncertain]
        user info: "Adversaries may perform supply chain compromise attacks to gain control of hardware before it is put into use."
        developer info: "Based on supply chain attacks in icsLang as designed by Sotirios."
        modeler info: "The probability function and its value is just an estimation! The Hardware supply chain attack represents an attacker being able to tamper with the hardware/firmware before the deployment of the product and not alterations made to the hardware/firmware once it is operating."
        ->  bypassHardwareModificationsProtection

      # supplyChainAuditing
        user info: "Auditing inside the supply chain can detect possible supply chain attacks."
        developer info: "Mitigation moved into coreLang from icsLang. Originally designed by Sotirios."
        ->  supplyChainAttack

      | physicalAccess
        user info: "Attacker has physical access to the location where the hardware is physically deployed. They could then deny the hardware, locally connect to the hosted applications, and exploit physical vulnerabilities."
        ->  deny,
            sysExecutedApps.localConnect,
            attemptHardwareModifications

      | attemptHardwareModifications @hidden
        developer info: "Intermediate attack step."
        ->  successfulHardwareModifications

      & successfulHardwareModifications @hidden
        developer info: "Intermediate attack step to enable defences."
        ->  hardwareModifications

      | hardwareModifications
        user info: "Attacker is able to modify the hardware setup. They could then exploit physical vulnerabilities or software vulnerabilities that require physical access."
        ->  attemptUseVulnerability,
            sysExecutedApps.physicalAccessAchieved

      # hardwareModificationsProtection
        user info: "This defence protects against unauthorized modifications to the hardware that would allow an attacker to exploit a hardware vulnerability or a user to connect malicious devices to it."
        developer info: "But it does not protect against denial of service attacks or local connect."
        ->  useVulnerability,
            successfulHardwareModifications,
            unsafeUserActivity

      | attemptUnsafeUserActivity
        user info: "Intermediate attack step that allows for the hardware modifications defence to reduce the impact of unsafe user activity."
        ->  unsafeUserActivity

      & unsafeUserActivity
        user info: "A user is performing unsafe actions on the hardware."
        developer info: "This exposes the Applications running on top of the hardware and fulfils the physical access requirement of SoftwareVulnerabilities associated with them."
        modeler info: "Currently only represents connecting a malicious removable media drive."
        ->  sysExecutedApps.attemptUnsafeUserActivity,
            sysExecutedApps.physicalAccessAchieved

      | deny {A}
        user info: "Denial of service (DoS) attack on hardware leads to DoS on all the applications running on it and hosted data."
        ->  sysExecutedApps.attemptDeny,
            hostedData.attemptDeny

      | read {C}
        user info: "Read on hardware leads to a read on all the applications running on it and hosted data."
        ->  sysExecutedApps.attemptRead,
            hostedData.attemptRead

      | modify {I}
        user info: "Modify on hardware leads to a modify/write on all the applications running on it and hosted data."
        ->  attemptGainFullAccess,
            sysExecutedApps.attemptModify,
            hostedData.attemptWrite

      | bypassHardwareModificationsProtection @hidden {C, I}
        user info: "The attacker can bypass the hardware modifications protection and gain full access after performing a supply chain attack."
        ->  attemptGainFullAccess
    }

    asset SoftwareProduct extends Information
      user info: "A software product is a specific type of software/application which can be associated with specific vulnerabilities."
      developer info: "This asset is only introduced in order to improve the usability of the language."
    {
      | compromiseApplication
        user info: "If the origin of a software product is compromised (modified maliciously) then the associated application should also be fully compromised."
        ->  softApplications.attemptFullAccessAfterSoftProdCompromise

      | readApplication
        user info: "If the vulnerability has a read impact, it should propagate that on all the applications."
        ->  softApplications.attemptReadAfterSoftProdVulnerability

      | modifyApplication
        user info: "If the vulnerability has a modify impact, it should propagate that on all the applications."
        ->  softApplications.attemptModifyAfterSoftProdVulnerability

      | denyApplication
        user info: "If the vulnerability has a deny impact, it should propagate that on all the applications."
        ->  softApplications.attemptDenyAfterSoftProdVulnerability

      | write @Override
        developer info: "If the attacker is able to write the software product they are able to compromise the applications using it."
        +>  compromiseApplication
    }

    asset Application
      user info: "An application models pretty much everything that is executed or can execute other applications."
    {
      let allVulnerabilities = vulnerabilities \/ appSoftProduct.softProductVulnerabilities

      let allApplicationConnections = (appConnections \/ outgoingAppConnections \/ ingoingAppConnections)
      let clientApplicationConnections = (appConnections \/ outgoingAppConnections)
      let serverApplicationConnections = (appConnections \/ ingoingAppConnections)

      # disabled [Disabled]
        user info: "If application is disabled it should behave as nonexistent, thus all attack vectors are removed."
        developer info: "This would even allow us to have a much more dynamic and probabilistic aspect on our model and simulations."
        ->  specificAccessFromLocalConnection,
            specificAccessFromNetworkConnection,
            localAccess,
            networkAccess,
            fullAccessAfterSoftProdVulnerability,
            readAfterSoftProdVulnerability,
            modifyAfterSoftProdVulnerability,
            denyAfterSoftProdVulnerability,
            successfulReverseReach,
            successfulUseVulnerability,
            successfulApplicationRespondConnectThroughData,
            successfulRead,
            successfulModify,
            successfulDeny

      | attemptUseVulnerability @hidden
        developer info: "Attempt to use the connected vulnerabilities, when able to locally or via network connect to the application or when local interaction is possible."
        ->  successfulUseVulnerability

      & successfulUseVulnerability @hidden
        developer info: "Intermediate attack step to model the case where vulnerabilities should not be compromised because application is disabled."
        ->  useVulnerability

      | useVulnerability
        user info: "Attempt to exploit the the connected vulnerabilities."
        ->  allVulnerabilities().attemptAbuse,
            attemptSoftwareProductAbuse,
            fullAccessAfterSoftProdVulnerability,
            readAfterSoftProdVulnerability,
            modifyAfterSoftProdVulnerability,
            denyAfterSoftProdVulnerability

      | attemptReverseReach
        developer info: "This attack step needs to be called in order to have reverse reach start propagating from this Application to the rest of the assets."
        modeller info: "No other attack step on the Application asset triggers this attack step which means that it must be explicitly triggered by the modeller if the attacker is assumed to have reverse reachability on it."
        ->  successfulReverseReach

      & successfulReverseReach @hidden
        developer info: "Intermediate attack step to model defences."
        ->  reverseReach

      | reverseReach @hidden
        developer info: "Reverse reach is used to determine whether or not the attacker can be reached by the user."
        ->  networks.attemptReverseReach,
            clientAccessNetworks.attemptReverseReach,
            serverApplicationConnections().attemptReverseReach,
            appExecutedApps.attemptReverseReach,
            unsafeUserActivityWithAttackerInteraction,
            containedData.attemptReverseReach,
            sentData.attemptReverseReach,
            receivedData.attemptReverseReach,
            networkConnectViaResponse

      | localConnect
        user info: "An attacker with low-privilege access on the executing instance is assumed to be able to locally (on the same host i.e. using loopback) interact with the application."
        ->  localAccess,
            specificAccessFromLocalConnection,
            attemptUseVulnerability, // Connection to all possible vulnerabilities that might be connected to the Application
            allVulnerabilities().localAccessAchieved,
            softwareProductVulnerabilityLocalAccessAchieved

      | networkConnect
        user info: "An attacker can connect to any network exposed application and attempt to authenticate or trigger vulnerabilities."
        ->  networkConnectWithoutTriggeringVulnerabilities,
            attemptUseVulnerability, // Connection to all possible vulnerabilities that might be connected to the Application
            allVulnerabilities().networkAccessAchieved,
            softwareProductVulnerabilityNetworkAccessAchieved

      | networkConnectWithoutTriggeringVulnerabilities @hidden
        developer info: "This attack step is used if the network connection occurs via a ConnectionRule that has its payload inspected, in which case the attacker can still authenticate, but they cannot trigger vulnerabilities."
        ->  networkAccess,
            specificAccessFromNetworkConnection

      | accessNetworkAndConnections
        user info: "An attacker is also possible to access the network(s) and connections to which this application is connected to, and perform client-side attacks."
        ->  networks.access,
            clientAccessNetworks.access,
            clientApplicationConnections().attemptConnectToApplications,
            clientApplicationConnections().attemptAccessNetworks

      | attemptNetworkConnectViaResponse
        developer info: "Intermediate attack step to handle defences."
        ->  networkConnectViaResponse

      & networkConnectViaResponse [VeryHardAndUncertain]
        user info: "An attacker may be able to respond to requests submitted by a client application."
        developer info: "Adopted from awsLang."
        modeler info: "The probability and its value are just estimations and are subject to change."
        ->  networkConnect

      & specificAccessFromLocalConnection @hidden
        developer info: "This intermediate step is used to represent that localConnect has happened before being able to get 'specificAccess'. Same as 'localAccess' attack step."
        ->  specificAccess

      & specificAccessFromNetworkConnection @hidden
        developer info: "This intermediate step is used to represent that networkConnect has happened before being able to get 'specificAccess'. Same as 'networkAccess' attack step."
        ->  specificAccess

      | specificAccess
        user info: "This level of access models a low-privilege access and requires all other privileges to be modeled separately."
        developer info: "An attacker with low-privilege access on the executing instance is assumed to be able to locally (on the same host i.e. using loopback) interact with the executed applications."
        ->  appExecutedApps.localConnect, // But also achieve localConnect on all child applications (this is something that needs to be reviewed again at a later stage)
            attemptLocalConnectVulnOnHost,
            attemptUseVulnerability,   // Connection to all possible vulnerabilities that might be connected to the Application
            containedData.attemptAccessFromIdentity, // This also enables the use of compromised identities but only after specificAccess is reached
            sentData.identityAttemptRead, // Both Data sent and received can be read
            receivedData.identityAttemptRead,
            sentData.identityAttemptWrite, // But only sent Data can be written
            attemptApplicationRespondConnectThroughData,
            accessNetworkAndConnections  // and access the network(s) and connections on/to which the app is connected

      | attemptLocalConnectVulnOnHost [HardAndUncertain]
        user info: "The attacker is able to break out of an application container/sandbox and try to exploit any vulnerability of the hypervisor/host application"
        modeler info: "The probability and its value are just estimations and are subject to change."
        ->  hostApp.attemptUseVulnerability

      | authenticate
        user info: "The attacker is able to authenticate with the appropriate credentials."
        ->  localAccess,
            networkAccess,
            allVulnerabilities().highPrivilegesAchieved,
            softwareProductVulnerabilityHighPrivilegesAchieved

      | specificAccessAuthenticate
        user info: "The attacker is able to authenticate with the appropriate specific access credentials."
        ->  specificAccessFromLocalConnection,
            specificAccessFromNetworkConnection,
            allVulnerabilities().lowPrivilegesAchieved,
            softwareProductVulnerabilityLowPrivilegesAchieved

      & localAccess @hidden
        developer info: "Intermediate attack steps for modeling the two requirements (reachability and authentication) for access."
        ->  fullAccess

      & networkAccess @hidden
        developer info: "Intermediate attack steps for modeling the two requirements (reachability and authentication) for access."
        ->  fullAccess

      | fullAccess {C,I,A}
        user info: "Legitimate (or not i.e. 0wned) full access on the Application, as root/administrator."
        ->  attemptRead,
            attemptModify,
            attemptDeny,
            appExecutedApps.attemptModify, // Gain access on all applications executed by this (host) application
            executionPrivIAMs.attemptAssume,  // Assume also the execution privilege identities of this application
            containedData.attemptAccess,  // and access on all the contained data
            sentData.attemptRead, // Both Data sent and received can be read
            receivedData.attemptRead,
            sentData.attemptWrite, // But only sent Data can be written
            attemptApplicationRespondConnectThroughData,
            accessNetworkAndConnections,  // and access the network(s) and connections on/to which the app is connected
            hostApp.localConnect,    // and localConnect on the host application
            managedRoutingFw.attemptModify, // if the routing firewall manager app is compromised the routing firewall should also be compromised
            specificAccess, // And also provide specificAccess, mainly for completeness and more intuitive results
            hostHardware.attemptUseVulnerability

      | physicalAccessAchieved @hidden
        developer info: "Intermediate attack step used to propagate physical access throughout application nesting."
        ->  allVulnerabilities().physicalAccessAchieved,
            softwareProductVulnerabilityPhysicalAccessAchieved,
            appExecutedApps.physicalAccessAchieved

      | attemptUnsafeActivityByUser @hidden
        developer info: "Intermediate attack step."
        ->  unsafeActivityByUser

      & unsafeActivityByUser
        user info: "The unsafe actions of users on this application open it up to attacks and enable vulnerabilities that require user interaction."
        ->  localConnect,
            networkConnect,
            allVulnerabilities().userInteractionAchieved

      & unsafeUserActivityWithAttackerInteraction @hidden
        developer info: "The attacker can be reached from this application and can therefore more easily exploit the unsafe user actions."
        ->  attemptUnsafeActivityByUser

      | unsafeUserActivityWithoutAttackerInteraction @hidden [VeryHardAndUncertain]
        developer info: "The attacker cannot be reached from this application. This means that the autonomous malicious code must either be able to do reconnaissance on the fly or the reconnaissance was done before and coded into it. This is much more complex and difficult than the situation where the attacker is reachable from the application. Important Note: This step should never directly or indirectly lead to reverse reach as it would fulfil the attacker interactivity requirements its counterpart is missing."
        ->  attemptUnsafeActivityByUser

      | attemptUnsafeUserActivity @hidden
        developer info: "This attack step represents a user with privileges on this application engaging in unsafe behaviour that could lead to exposing the application to the attacker."
        ->  unsafeUserActivityWithAttackerInteraction,
            unsafeUserActivityWithoutAttackerInteraction

      # supplyChainAuditing
        user info: "Auditing inside the supply chain can detect possible supply chain attacks."
        developer info: "Mitigation based on the hardware/firmware supply chain attack mitigation in icsLang as designed by Sotirios."
        ->  fullAccessAfterSoftProdCompromise

      | attemptFullAccessAfterSoftProdCompromise @hidden
        developer info: "Intermediate attack step."
        ->  fullAccessAfterSoftProdCompromise

      & fullAccessAfterSoftProdCompromise @hidden
        developer info: "Intermediate attack step."
        ->  fullAccess

      // Intermediate attack steps to allow SoftwareProduct Vulnerabilities to only happen after each Applications is reached by the attacker.
      | attemptFullAccessAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  fullAccessAfterSoftProdVulnerability

      | attemptReadAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  readAfterSoftProdVulnerability

      | attemptModifyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  modifyAfterSoftProdVulnerability

      | attemptDenyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  denyAfterSoftProdVulnerability

      E softwareCheck @hidden
        user info: "Existence attack step to only allow the connected attacks steps only if a SoftwareProduct is associated."
        <-  appSoftProduct
        ->  fullAccessAfterSoftProdVulnerability,
            readAfterSoftProdVulnerability,
            modifyAfterSoftProdVulnerability,
            denyAfterSoftProdVulnerability

      | softwareProductVulnerabilityLocalAccessAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  appSoftProduct.softProductVulnerabilities.localAccessAchieved,
            softwareProductAbuse

      | softwareProductVulnerabilityNetworkAccessAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  appSoftProduct.softProductVulnerabilities.networkAccessAchieved,
            softwareProductAbuse

      | softwareProductVulnerabilityPhysicalAccessAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  appSoftProduct.softProductVulnerabilities.physicalAccessAchieved,
            softwareProductAbuse

      | softwareProductVulnerabilityLowPrivilegesAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  appSoftProduct.softProductVulnerabilities.lowPrivilegesAchieved,
            softwareProductAbuse

      | softwareProductVulnerabilityHighPrivilegesAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  appSoftProduct.softProductVulnerabilities.highPrivilegesAchieved,
            softwareProductAbuse

      | softwareProductVulnerabilityUserInteractionAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  appSoftProduct.softProductVulnerabilities.userInteractionAchieved,
            softwareProductAbuse

      | attemptSoftwareProductAbuse @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  softwareProductAbuse

      & softwareProductAbuse @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        ->  fullAccessAfterSoftProdVulnerability,
            readAfterSoftProdVulnerability,
            modifyAfterSoftProdVulnerability,
            denyAfterSoftProdVulnerability

      & fullAccessAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  fullAccess

      & readAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  attemptRead

      & modifyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  attemptModify

      & denyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  attemptDeny

      | attemptApplicationRespondConnectThroughData @hidden
        developer info: "Intermediate attack step."
        ->  successfulApplicationRespondConnectThroughData

      & successfulApplicationRespondConnectThroughData @hidden
        developer info: "Intermediate attack step to model defences."
        ->  applicationRespondConnectThroughData

      | applicationRespondConnectThroughData @hidden
        user info: "After access on the application the contained data or data in transit can be used to attempt a respond connect to the client side application."
        modeler info: "This is an intermediate attack step that groups connections to attack steps."
        ->  receivedData.attemptApplicationRespondConnect

      | attemptRead @hidden
        developer info: "Intermediate attack step."
        ->  successfulRead

      & successfulRead @hidden
        developer info: "Intermediate attack step to model defences."
        ->  read

      | read {C}
        user info: "The attacker can read some or all of this service's code and data."
        developer info: "We don't model the services data, as we do not expect that information will be available to the parser. We also don't differentiate between service administrators and service users (e.g., mail service admins and users), as we have no information about the services. Adopted from awsLang."
        ->  containedData.attemptRead,
            appExecutedApps.attemptRead

      | attemptModify @hidden
        developer info: "Intermediate attack step."
        ->  successfulModify

      & successfulModify @hidden
        developer info: "Intermediate attack step to model defences."
        ->  modify

      | modify {I}
        user info: "The attacker can modify some or all of this service's data and/or source code."
        ->  containedData.attemptAccess,
            fullAccess

      | attemptDeny @hidden
        developer info: "Intermediate attack step."
        ->  successfulDeny

      & successfulDeny @hidden
        developer info: "Intermediate attack step to model defences."
        ->  deny

      | deny {A}
        user info: "The attacker can deny some or all functionality and data pertaining to this application/service as well as executed applications."
        ->  containedData.attemptDeny,
            appExecutedApps.attemptDeny

      & denyFromNetworkingAsset @hidden
        user info: "This is an intermediate attack step to only allow deny on an application when all the connection rules and networks associated with it are denied, because an app can be serving on many different ports."
        ->  attemptDeny
    }

    asset IDPS extends Application
      user info: "An IDPS is tasked with protecting other applications from malicious activity."
    {
      # effectiveness [Enabled]
        user info: "The effectiveness defence represents how capable the IDPS is to prevent disruptions from occurring on the associated applications."
        modeller info: "The disabled defence should inversely impact the effectiveness defence. However, because this is not currently implemented in coreLang it is up to the modeller to properly take this into account when setting the values of these defences."
        ->  protectionBypassed

      # disabled @Override @hidden [Disabled]
        modeller info: "As per the comment for the effectiveness defence, the disabled defence does not function as desired for the IDPS asset and should not be used. The effectiveness defence should be adjusted to reflect the likelihood that the IDPS is present instead."
        developer info: "It would be ideal to hide this defence when using modelling tools to avoid confusion."

      | protectionBypassed @hidden
        developer info: "The protection of the IDPS has been bypassed either as a result of attacker activity or due to some internal property of the IDPS."
        ->  protectedApps.useVulnerability, // The IDPS is no longer able to protect the apps assigned to it
            protectedApps.unsafeActivityByUser

      | fullAccess {C,I,A}
        +>  protectionBypassed // The application is no longer able to protect the apps assigned to it
    }

    asset PhysicalZone
      user info: "A physical zone is the location where hardware systems are physically deployed."
    {
      | gainPhysicalAccess
        user info: "By gaining access on a physical zone, physical access on the housed hardware is also gained."
        ->  hardwareSystems.physicalAccess,
            networks.physicalAccess
    }
}

category DataResources {

    asset Information
      user info: "Represents any type of information that might be contained inside Data."
    {
      | attemptAccess
        user info: "The attacker is attempting to access the information."

      | attemptReadFromReplica @hidden
        developer info: "Reading one replica allows the attacker to read all other replicas as well since the information contained in them is the same."
        ->  successfulReadFromReplica

      & attemptWriteFromReplica @hidden
        developer info: "Information can be overwritten only if all replicas have been overwritten."
        ->  successfulWriteFromReplica

      & attemptDeleteFromReplica @hidden
        developer info: "Information can be deleted only if all replicas have been deleted."
        ->  successfulDeleteFromReplica

      & attemptDenyFromReplica @hidden
        developer info: "Information can be denied only if all replicas have been denied."
        ->  successfulDenyFromReplica

      | attemptExtractFromReplica @hidden
        developer info: "The attacker attempts to extract the information."
        ->  successfulExtractFromReplica

      & successfulReadFromReplica @hidden
        developer info: "Intermediate attack step to model defences."
        ->  read

      & successfulWriteFromReplica @hidden
        developer info: "Intermediate attack step to model defences."
        ->  write

      & successfulDeleteFromReplica @hidden
        developer info: "Intermediate attack step to model defences."
        ->  delete

      & successfulDenyFromReplica @hidden
        developer info: "Intermediate attack step to model defences."
        ->  deny

      & successfulExtractFromReplica @hidden
        developer info: "Intermediate attack step to model defences."
        ->  extract

      | read
        user info: "The attacker is able to read the information. They may still be unable to extract it."
        ->  dataReplicas.read,
            containerData.read

      | write
        user info: "The attacker is able to write the information."
        ->  dataReplicas.write,
            containerData.write

      | delete
        user info: "The attacker is able to delete the information."
        ->  dataReplicas.delete,
            containerData.delete

      | deny
        user info: "The attacker is able to deny the information."
        ->  dataReplicas.deny,
            containerData.deny

      | extract
        user info: "The attacker is able to extract the information. This means that they have a path available through which they can transfer the information back to a system they control."
    }

    asset Data
      user info: "Any form of data that can be stored or transmitted."
      developer info: "Adopted from awsLang but significantly changed."
    {
      | attemptAccess
        user info: "Attempt to access the data, this might fail if the 'dataNotPresent' defense is used."
        ->  access

      | attemptAccessFromIdentity
        user info: "Access the data through a compormised identity."
        ->  identityRead,
            identityWrite,
            identityDelete

      & access
        user info: "Access the data."
        ->  attemptRead,
            attemptWrite,
            attemptDelete,
            containedData.attemptAccess

      !E dataEncrypted @hidden
        user info: "If the data are encrypted then accessing them requires the associated encryption credentials/key."
        developer info: "Data will be considered as encrypted if there is at least one Credentials instance associated with it. Otherwise, 'accessUnencryptedData' is reached."
        <-  encryptCreds
        ->  accessUnencryptedData

      !E dataSigned @hidden
        user info: "If the data are authenticated, then modifying them is not possible to achieve."
        developer info: "Data will be considered as encrypted if there is at least one Credentials instance associated with it. Otherwise, 'accessUnencryptedData' is reached."
        <-  signingCreds
        ->  accessUnsignedData

      & accessUnencryptedData @hidden
        user info: "If data are unencrypted then access them."
        ->  accessDecryptedData

      & accessUnsignedData @hidden
        user info: "If data are unsigned then alter them."
        ->  accessSpoofedData

      | accessSpoofedData @hidden
        user info: "Intermediate attack step to only allow effects of 'accessUnsignedData' on data after compromising the signing credentials or signing is disabled."
        ->  containedData*.applicationRespondConnect,
            containedData*.successfulWrite

      | accessDecryptedData @hidden
        user info: "Intermediate attack step to only allow effects of 'accessUnencryptedData' on data after compromising the encryption credentials or encryption is disabled."
        ->  access,
            applicationRespondConnect,
            successfulRead,
            successfulWrite,
            successfulDelete

      # dataNotPresent [Disabled]
        user info: "It should be used to model the probability of data actually not existing on the connected container (i.e. Hardware, Application, Connection, etc.)."
        developer info: "This attack step is in series with the 'accessUnencryptedData' attack step because there is no reason to defend encrypted data (or deny them) if they do not exist..."
        ->  access,
            applicationRespondConnect,
            successfulRead,
            successfulWrite,
            successfulDeny,
            successfulDelete

      | attemptApplicationRespondConnect @hidden
        developer info: "Intermediate attack step to handle defenses."
        ->  applicationRespondConnect

      & applicationRespondConnect
        user info: "If data is manInTheMiddled or the server side application is compromised, then respond connect to the client side application can be done."
        ->  senderApp.attemptNetworkConnectViaResponse

      | attemptRead @hidden
        user info: "Attempt to read the data."
        ->  successfulRead

      | identityAttemptRead @hidden
        user info: "Attempt to read the data through a compromised identity."
        ->  identityRead

      & identityRead @hidden
        developer info: "Intermediate attack step to only allow operations on data after both access and identity assume is compromised."
        ->  attemptRead

      | attemptWrite @hidden
        user info: "Attempt to write on the data."
        ->  successfulWrite

      | identityAttemptWrite @hidden
        user info: "Attempt to write the data through a compromised identity."
        ->  identityWrite

      & identityWrite @hidden
        developer info: "Intermediate attack step to only allow operations on data after both access and identity assume is compromised."
        ->  attemptWrite

      | attemptDelete @hidden
         user info: "Attempt to delete the data."
        -> successfulDelete

      | identityAttemptDelete @hidden
        user info: "Attempt to delete the data through a compromised identity."
        ->  identityDelete

      & identityDelete @hidden
        developer info: "Intermediate attack step to only allow operations on data after both access and identity assume is compromised."
        ->  attemptDelete

      & successfulRead @hidden
        developer info: "Intermediate attack step to model the requirements."
        ->  read

      | read {C}
        user info: "The attacker can read the data. This means that the data can be used for further attack steps, but they are not necessarily obtained by the attacker. The extract attack step covers the scenario where the attacker actually collects the data."
        ->  containedData.attemptRead,
            information.read,
            replicatedInformation.attemptReadFromReplica,
            extract

      & successfulWrite @hidden
        developer info: "Intermediate attack step to model the requirements."
        ->  write

      | write {I}
        user info: "The attacker can write to the location of the data, effectively modifying or deleting it."
        ->  containedData.attemptWrite,
            information.write,
            replicatedInformation.attemptWriteFromReplica,
            attemptDelete,
            compromiseAppOrigin

      & successfulDelete @hidden
        developer info: "Intermediate attack step to model the requirements."
        ->  delete

      | delete {I,A}
        user info: "The attacker can delete the data."
        ->  containedData.attemptDelete,
            information.delete,
            replicatedInformation.attemptDeleteFromReplica,
            attemptDeny

      | attemptDeny @hidden
        developer info: "Intermediate attack step to only allow deny on data after only if 'dataNotPresent' defense is disabled."
        ->  successfulDeny

      & successfulDeny @hidden
        developer info: "Intermediate attack step to model the requirements."
        ->  deny

      | deny {A}
        user info: "If a DoS is performed data are denied, it has the same effects as deleting the data."
        ->  containedData.attemptDeny,
            information.deny,
            replicatedInformation.attemptDenyFromReplica

      | attemptReverseReach @hidden
        developer info: "Intermediate attack step."
        ->  reverseReach

      & reverseReach @hidden
        developer info: "Reverse reach for Data is used to determine whether or not the data can be transferred to attacker."
        ->  extract,
            containedData.attemptReverseReach

      & extract
        user info: "The attacker can extract the data. The read attack step represents just being able to make use of the data for further attack steps without the attacker obtaining it."
        ->  information.extract,
            replicatedInformation.attemptExtractFromReplica

      | compromiseAppOrigin
        user info: "If origin data are modified/written then the software product is also compromised which effectively also compromises the application."
        ->  originSoftwareProduct.compromiseApplication
    }
}

category IAM {

    abstract asset IAMObject
      user info: "An IAM object represents the base logic shared by all assets used for Identity and Access Management roles(Identity, Group, Privileges)."
    {
      # disabled [Disabled]
        user info: "It should be used to model the probability that the IAM object does not actually exist."
        ->  successfulAssume

      | attemptAssume
        user info: "Attempt to assume the privileges associated with the IAM object. If disabled this will not be possible."
        ->  successfulAssume

      & successfulAssume @hidden
        developer info: "Intermediate attack step to model the requirements for the assume attack step."
        ->  assume

      | assume
        user info: "When an attacker is able to assume an IAM asset the privileges associated with it can always be exploited, other behaviour is asset specific."
        ->  execPrivApps.authenticate,
            highPrivApps.authenticate,
            lowPrivApps.specificAccessAuthenticate,
            readPrivData.identityAttemptRead,
            writePrivData.identityAttemptWrite,
            deletePrivData.identityAttemptDelete,
            managedIAMs.attemptAssume
    }

    asset Identity extends IAMObject
      user info: "An identity models an IAM identity that should then be associated with privileges on other instances."
      developer info: "An identity can be visualised as a group of assumable roles that can be associated with many credentials."
    {
      | assume @Override {C,I,A}
        user info: "After authentication or compromise of an account/identity, assume its privileges."
        developer info: "This is both legitimate and illegitimate access! Also assume all the privileges of the parent identities (on the above level/inherited by this identity) because those represent the group of (inherited) roles."
        +>  parentId.attemptAssume,
            memberOf.attemptAssume,
            identityPrivileges.attemptAssume
    }

    asset Privileges extends IAMObject
      user info: "A privileges asset can be associated with an identity to group a set of given privileges on Applications and Data."
    {
      | assume @Override {C,I,A}
        user info: "After authentication or compromise of an account/identity, assume its privileges."
        developer info: "Assume identity/group the privileges are associated with since the privileges are simply an extension of it."
        +>  privilegeIdentities.attemptAssume,
            privilegeGroups.attemptAssume
    }

    asset Group extends IAMObject
      user info: "A group is a way to group together identities and/or groups. This allows the expression of hierarchical IAM (structured inheritance)."
      modeler info: "Groups can be used instead of nested identities to make the model more intuitive and clearer to understand."
    {
      | assume @Override {C,I,A}
        user info: "If an identity of a group is compromised then the whole group (i.e. all other privileges of the group) should be considered as compromised. Furthermore, the parent groups should also be considered compromised."
        developer info: "The parent groups should be compromised because all the privileges of the parent groups are inherited on the children groups but lower children groups should not be compromised because lower levels might have inherited plus additional privileges."
        +>  parentGroup.attemptAssume,
            groupPrivileges.attemptAssume
    }

    asset Credentials extends Information
      user info: "Credentials can be used to get access to an Identity, but they can also be used as an encryption/signing key for Data."
      modeler info: "Credentials represent a variety of access control mechanism(e.g. username and password pair, keycards, biometric data)."
    {
      # notDisclosed [Enabled]
        user info: "Describes the case where the password/credential is leaked to some location, it can then be available to the attacker."
        ->  useLeakedCredentials

      # notGuessable [Enabled]
        user info: "Describes if the credentials can be guessed by the attacker(e. g. they represent a password or passphrase)."
        ->  guessCredentials

      # unique [Enabled]
        user info: "Describes if the credentials are known to be unique and therefore cannot be used in a credentials reuse attack."
        ->  credentialsReuse,
            propagateOneCredentialCompromised

      # notPhishable [Disabled]
        user info: "Describes if the credentials cannot be phished(they are biometric, e. g. fingerprints or iris scans, or physical, e. g. access cards or keys, elements)."
        ->  credentialTheft

      | read @Override
        developer info: "If the attacker is able to read the information containing credentials we assume that they are compromised."
        +> attemptUse

      | useLeakedCredentials [EasyAndCertain]
        user info: "If the password/credential is leaked to some location, it can then be available to the attacker and therefore it can be used."
        ->  attemptUse

      | attemptCredentialsReuse @hidden
        developer info: "Intermediate step used to trigger the reuse attack step on other credentials belonging to the same user."
        ->  credentialsReuse,
            requiredFactors.attemptCredentialsReuse

      & credentialsReuse
        developer info: "The user is reusing credentials which means that the attacker is able to compromise all of the non-unique credentials associated with this user."
        ->  attemptUse

      | attemptUse
        user info: "Someone is using the credentials to perform a legitimate authentication."
        ->  use

      & use {C}
        user info: "Someone is using the credentials to perform a legitimate authentication."
        ->  identities.attemptAssume,
            encryptedData.accessDecryptedData,
            signedData.accessSpoofedData,
            attemptPropagateOneCredentialCompromised,
            credentials.use,
            hashes.attemptUse,
            origCreds.guessCredentialsFromHash

      | attemptPropagateOneCredentialCompromised @hidden
        developer info: "Intermediate step used to propagate the credentials reuse attack step."
        ->  propagateOneCredentialCompromised

      & propagateOneCredentialCompromised @hidden
        developer info: "Intermediate step used to propagate the credentials reuse attack step."
        ->  credentials*.identities.users.oneCredentialCompromised

      | attemptAccess
        user info: "The attacker is attempting to access the credentials."
        ->  attemptUse

      | attemptCredentialTheft @hidden
        developer info: "Intermediate step used to trigger the credential theft attack step."
        ->  credentialTheft,
            requiredFactors.attemptCredentialTheft

      & credentialTheft
        user info: "The attacker is able to steal the credentials."
        ->  attemptUse

      | weakCredentials @hidden
        developer info: "Intermediate step used to represent how weak the credentials the user employs are. This is inversely related to the securityAwareness defence on the User asset."
        ->  guessCredentials,
            requiredFactors.weakCredentials

      !E credsHashed @hidden
        developer info: "If there are no associated hashes the assumption is that the credentials are guessable without any additional requirements."
        <-  hashes
        ->  guessCredentialsFromHash

      | guessCredentialsFromHash @hidden
        developer info: "If hashes are associated with this Credentials asset the assumption is that one of those hashes is required by the attacker to be able to perform a guessing attack."
        ->  guessCredentials

      & guessCredentials [HardAndUncertain]
        user info: "The attacker can attempt to just guess a set of credentials. The likelihood of succeeding is depend on how strong the credentials are."
        developer info: "We should research the probability we want to use for this attack step more."
        ->  attemptUse
    }
}

category User {

    asset User
      user info: "This asset represents the user himself. It is the suitable attack surface for social engineering attacks!"
    {
      # noPasswordReuse [Enabled]
        user info: "If one credential of that user is compromised there is a probability that all other credentials of that user are also compromised."
        ->  passwordReuseCompromise

      # securityAwareness
        user info: "The security awareness of the user makes it less likely that social engineering would be successful and reduces the likelihood that the user will engage in unsafe behaviour."
        ->  socialEngineering,
            unsafeUserActivity,
            weakCredentials,
            deliverMaliciousRemovableMedia

      | oneCredentialCompromised @hidden
        developer info: "This intermediate attack step is needed in order to block passwordReuseCompromise when no other credential is first compromised."
        ->  passwordReuseCompromise

      & passwordReuseCompromise @hidden
        developer info: "If one reused credential of that user is compromised then, all other credentials of that user can also be compromised."
        ->  userIds.credentials.attemptCredentialsReuse

      | weakCredentials @hidden
        developer info: "Intermediate attack step that defines the strength of all of the Credentials associated with the user. This is inversely proportional with the user's securityAwareness defence."
        ->  userIds.credentials.weakCredentials

      | attemptSocialEngineering
        developer info: "Intermediate attack step that allows for security awareness to reduce the impact of social engineering operations."
        ->  socialEngineering

      & socialEngineering @hidden
        modeler info: "An attacker can try to perform social engineering techniques such as phishing."
        developer info: "In the future, other social engineering techniques should be connected to this attack step."
        ->  phishUser,
            unsafeUserActivity

      | attemptDeliverMaliciousRemovableMedia
        user info: "Intermediate attack step that allows for security awareness to reduce the impact of delivering malicious removable media."
        ->  deliverMaliciousRemovableMedia

      & deliverMaliciousRemovableMedia @hidden [Exponential(0.01)]
        modeler info: "An attacker can try to deliver a removable media drive(e.g. USB drive) containing malicious code to a location accessible to the target users."
        developer info: "The probability distribution is entirely arbitrary and should be researched in greater detail."
        ->  userIds.attemptAssume,
            physicalZones.hardwareSystems.attemptUnsafeUserActivity,
            hardwareSystems.attemptUnsafeUserActivity

      | phishUser @hidden
        modeler info: "The attacker can phish the user to gain access to their credentials."
        ->  attemptCredentialTheft

      | attemptCredentialTheft @hidden
        developer info: "Trick the user to provide their credentials."
        ->  credentialTheft

      | credentialTheft @hidden [HardAndUncertain]
        developer info: "This attack is hard to happen."
        modeler info: "Distribution: Bernoulli(0.5) * Exponential(0.1), source: Sommestad (2011) Password authentication attacks: a survey of attacks and when they will succeed, suggest to use Bernoulli(0.05)"
        ->  userIds.credentials.attemptCredentialTheft

      & unsafeUserActivity @hidden [Exponential(0.03)]
        developer info: "The user can engage in unsafe behaviour that could allow the attacker to gain access to the applications the user has access to."
        modeler info: "An attacker may trigger the assume step on identities belonging to the user without being able to reach (or be reached) via any of the Applications that the identity has access to. This represents an unmaterialised threat in that scenario. The choice of probability is entirely arbitrary and should be replaced with a scientifically grounded distribution."
        ->  userIds.attemptAssume,
            userIds.execPrivApps.attemptUnsafeUserActivity,
            userIds.identityPrivileges.execPrivApps.attemptUnsafeUserActivity,
            userIds.highPrivApps.attemptUnsafeUserActivity,
            userIds.identityPrivileges.highPrivApps.attemptUnsafeUserActivity,
            userIds.lowPrivApps.attemptUnsafeUserActivity,
            userIds.identityPrivileges.lowPrivApps.attemptUnsafeUserActivity
    }
}

category Networking {

    asset Network
      user info: "A network (zone) is a set of network accessible applications and data."
      developer info: "The network asset tries to cover all the levels of the OSI stack in a very abstract and compact way (i.e. it tries to represent all the OSI layers). For example it will try to cover both ARP attacks (that are Level 2) but also DNS/HTTP spoofing attacks (that are Level 7)."
    {
      let allNetApplications = (clientApplications \/ applications)
      let allowedNetworkConnections =  netConnections \/ outgoingNetConnections
      let allowedApplicationConnections = (netConnections \/ outgoingNetConnections)
      let allNetConnections = netConnections \/ ingoingNetConnections \/ outgoingNetConnections \/ diodeIngoingNetConnections
      let allowedApplicationConnectionsApplications = allNetApplications() \/ allNetConnections().applications

      | physicalAccess {C, A}
        developer info: "Attacker has physical access on the network. This means he can cut wires/fibers, connect using iLOs, eavesdrop and get proper network access."
        ->  denialOfService,
            eavesdropAfterPhysicalAccess,
            attemptAccess,
            bypassAccessControl

      # networkAccessControl
        user info: "Access control protects from unauthorized physical access on the network."
        ->  eavesdropAfterPhysicalAccess,
            attemptAccess

      | bypassAccessControl [VeryHardAndUncertain]
        user info: "If access control is enabled, the attacker can still try to bypass it and gain access on the network."
        ->  successfulAccess

      & attemptAccess @hidden
        user info: "Access on a Network can be attempted after physicalAccess."
        ->  access

      | access
        user info: "Access provides connect to all reachable applications."
        ->  successfulAccess

      | successfulAccess @hidden
        developer info: "This is an intermediate attack step to prevent repeating code."
        ->  allowedApplicationConnections().attemptConnectToApplications,
            applications.networkConnect,
            clientApplications.attemptNetworkConnectViaResponse,
            accessNetworkData,
            networkForwarding,
            denialOfService,
            attemptReverseReach

      | attemptReverseReach @hidden
        developer info: "Intermediate attack step."
        ->  reverseReach

      & reverseReach @hidden
        developer info: "Reverse reach is used to determine whether or not the attacker can be reached by the user."
        ->  (netConnections \/ ingoingNetConnections \/ diodeIngoingNetConnections).attemptReverseReach,
            clientApplications.attemptReverseReach,
            applications.attemptReverseReach

      | networkForwarding
        developer info: "By using the allowed connections (connection rules), forwarding from one network to another network or applications can happen."
          ->  allowedNetworkConnections().attemptAccessNetworks,
              allowedNetworkConnections().attemptConnectToApplications

      | denialOfService {A}
        user info: "If a DoS is performed it affects, the applications communicating over the network as well as the connected application."
        ->  allNetConnections().attemptDenialOfService,
            allowedApplicationConnectionsApplications().denyFromNetworkingAsset

      | accessNetworkData
        user info: "Access also the data that are network-wide available."
        ->  eavesdrop,
            bypassEavesdropProtection,
            manInTheMiddle,
            bypassMitMProtection

      # eavesdropDefense
        user info: "This defense protects from eavesdrop attacks. If this defense is disabled, then it is equivalent to the network being considered a broadcast network."
        modeler info: "If this defense is enabled, attacks such as ARP spoofing should however, still be possible. This can be done by assigning a Bernoulli distribution to this defense."
        ->  eavesdrop,
            eavesdropAfterPhysicalAccess

      # manInTheMiddleDefense
        user info: "This defense protects against man-in-the-middle (MitM) attacks that are originating either form the network layer (like ARP spoofing) or by manipulating the higher network layers (like DNS poisoning)."
        ->  manInTheMiddle

      & eavesdrop {C}
        user info: "An attacker that performs an eavesdrop attack on a network tries to access all the transferred data over that network."
        ->  successfulEavesdrop

      | bypassEavesdropProtection {C} [HardAndUncertain]
        user info: "The eavesdrop protection can be bypassed."
        ->  successfulEavesdrop

      | successfulEavesdrop @hidden
        developer info: "This is an intermediate attack step to prevent repeating code."
        ->  transitData.attemptRead

      & manInTheMiddle {C, I}
        user info: "An attacker that performs a MitM attack on a network tries to read and modify all the transferred data over that network."
        ->  successfulManInTheMiddle

      | bypassMitMProtection {C, I} [HardAndUncertain]
        user info: "The MitM protection can be bypassed."
        ->  successfulManInTheMiddle

      | successfulManInTheMiddle @hidden
        developer info: "This is an intermediate attack step to prevent repeating code."
        ->  transitData.attemptRead,
            transitData.attemptWrite,
            transitData.attemptApplicationRespondConnect

      & eavesdropAfterPhysicalAccess @hidden {C}
        user info: "If a network is not a switching network and the attacker has physical access on it, eavesdrop can happen."
        ->  successfulEavesdrop
    }

    asset RoutingFirewall extends Application
      user info: "A routing firewall specifies a router with firewall capabilities that connects many networks."
    {
      | denialOfService {A}
       user info: "A DoS attack should cascade on the connected networks and associated connections"
        ->  connectionRules.attemptDenialOfService

      | fullAccess {I, A}
        developer info: "If full access is achieved on RoutingFirewall then it is 0wned and all connections can be allowed! This can happen by compromising the manager application."
        +>  (connectionRules.networks \/ connectionRules.outNetworks \/ connectionRules.inNetworks \/ connectionRules.diodeInNetworks).access,
            connectionRules.applications.networkConnect
    }

    asset ConnectionRule
      user info: "This asset is used to model firewall rules between Applications and/or Networks. The association selected (bi/uni-directional) only describes the connection initiation."
      developer info: "This asset is mainly used to model the functionality of a network connection through a firewall. If Data is added, then it also models the data in transit."
    {
      let allApplications = (applications \/ inApplications \/ outApplications)
      let clientApplications = (applications \/ outApplications)
      let serverApplications = (applications \/ inApplications)

      # restricted [Disabled]
        user info: "The restricted defence can be used to probabilistically model the likelihood of both the protocols required by the attack being enabled or the existence of the ConnectionRule altogether."
        ->  accessNetworks,
            connectToApplications,
            connectToApplicationsWithoutTriggeringVulnerabilities,
            denialOfService,
            reverseReach

      # payloadInspection [Disabled]
        user info: "If enabled, then the traffic is considered to be inspected and filtered by an IDPS that can detect and stop malicious payloads, effectively allowing only legitimate communication(i. e. network-level vulnerabilities cannot be exploited)."
        ->  connectToApplications,
            reverseReach

      // All the hidden attack steps below are hidden because they are just used for the internal mechanics of the ConnectionRules
      | attemptReverseReach @hidden
        developer info: "Intermediate attack step."
        ->  reverseReach

      & reverseReach @hidden
        developer info: "Reverse reach is used to determine whether or not the attacker can be reached by the user."
        ->  clientApplications().attemptReverseReach,
            (networks \/ outNetworks).attemptReverseReach

      | attemptAccessNetworks @hidden
        developer info: "Intermediate attack step."
        ->  accessNetworks

      & accessNetworks
        developer info: "Access all networks that are associated with this ConnectionRule."
        ->  (networks  \/ inNetworks  \/ diodeInNetworks).access

      | attemptConnectToApplications @hidden
        developer info: "Intermediate attack step."
        ->  connectToApplications,
            connectToApplicationsWithoutTriggeringVulnerabilities

      & connectToApplications @hidden
        developer info: "Connect to all the (server) Applications that are associated with this ConnectionRule."
        ->  serverApplications().networkConnect

      & connectToApplicationsWithoutTriggeringVulnerabilities @hidden
        developer info: "Connect to all the (server) Applications that are associated with this ConnectionRule, but without triggering vulnerabilities on them. This attack step is used to allow legitimate traffic even when payload inspection is enabled on the connection."
        ->  serverApplications().networkConnectWithoutTriggeringVulnerabilities

      | attemptDenialOfService @hidden
        developer info: "Intermediate attack step."
        ->  denialOfService

      & denialOfService {A}
        ->  allApplications().denyFromNetworkingAsset
    }
}

associations {
  Hardware         [hostHardware]      0..1 <-- SysExecution          --> *    [sysExecutedApps]        Application
      developer info: "Hardware on which Applications are running. The host hardware is not mandatory to be specified but if it is, it adds on the model!"
  Application      [hostApp]           0..1 <-- AppExecution          --> *    [appExecutedApps]        Application
      developer info: "Application 1 runs application 2 runs application 3. (Where application 1 can be an OS, application 2 is a VM and application 3 is app running on the VM."
  IDPS             [protectorIDPSs]       * <-- AppProtection         --> *    [protectedApps]          Application
      developer info: "IDPSs can provide protection to other applications."
  SoftwareProduct  [appSoftProduct]    0..1 <-- AppSoftwareProduct    --> *    [softApplications]       Application
      user info: "An application can be associated with a software product that has some specific characteristics such as specific Vulnerabilities."
  PhysicalZone     [physicalZones]        * <-- ZoneInclusion         --> *    [hardwareSystems]        Hardware
      developer info: "Access on PhysicalZone will give physicalAccess on the deployed Hardware, but access to the hardware does not provide access to the physical zone (e.g. iLOs)."
  PhysicalZone     [physicalZones]        * <-- ZoneInclusion         --> *    [networks]               Network
      developer info: "Access on PhysicalZone will give physicalAccess on the deployed networks, but access to the network does not provide access to the physical zone."
  PhysicalZone     [physicalZones]        * <-- ZoneAccess            --> *    [users]                  User
      developer info: "A user may have access to different physical zones."
  Hardware         [hardwareSystems]      * <-- HardwareAccess        --> *    [users]                  User
      developer info: "A user may have access to different hardware systems, rigs, or components."
  // ### Networking associations
  RoutingFirewall  [routingFirewalls]  0..1 <-- ConnectionRule        --> *    [connectionRules]        ConnectionRule
      user info: "A routing firewall has routing or firewall rules specified by connections between networks or applications respectively."
  RoutingFirewall  [managedRoutingFw]     * <-- ManagedBy             --> 0..1 [managerApp]             Application
      user info: "A routing firewall can have an admin/manager interface (application) that is accessible from a network location."
  Network          [networks]             * <-- NetworkExposure       --> *    [applications]           Application
      user info: "An application can communicate / be exposed on a network."
      modeler info: "This is DEPRECATED and should only be used by fully aware modelers."
      developer info: "This can equivalently be modeled using a ConnectionRule but this direct approach should be prefered in the case where the application is “located” in the same network as the host on which it is running."
  Network          [clientAccessNetworks] * <-- ClientAccess          --> *    [clientApplications]     Application
      user info: "A client application can communicate over a network."
  Application      [applications]         * <-- ApplicationConnection --> *    [appConnections]         ConnectionRule
      user info: "An application can communicate over one or more (mesh type) bidirectional connections."
      modeler info: "ConnectionRules associated with Applications are practically expressing a traffic flow."
  Application      [inApplications]       * <-- InApplicationConnection --> *  [ingoingAppConnections]  ConnectionRule
      user info: "Two or more applications can also be inter-connected via a uni-directional connection. In means that this is the server side application, awaiting incoming connections."
  Application      [outApplications]      * <-- OutApplicationConnection --> * [outgoingAppConnections] ConnectionRule
      user info: "Two or more applications can also be inter-connected via a uni-directional connection. Out means that this is the client side application initiating connections."
  Network          [networks]             * <-- NetworkConnection     --> *    [netConnections]         ConnectionRule
      user info: "Two or more networks can also be inter-connected via a bidirectional connection."
  Network          [inNetworks]           * <-- InNetworkConnection   --> *    [ingoingNetConnections]  ConnectionRule
      user info: "Two or more networks can also be inter-connected via a uni-directional connection. In means that ingoing traffic to the network is allowed."
  Network          [outNetworks]          * <-- OutNetworkConnection  --> *    [outgoingNetConnections] ConnectionRule
      user info: "Two or more networks can also be inter-connected via a uni-directional connection. Out means that outgoing traffic from the network is allowed."
  Network          [diodeInNetworks]      * <-- DiodeInNetworkConnection --> * [diodeIngoingNetConnections] ConnectionRule
      user info: "Two or more networks can also be inter-connected via a uni-directional connection that acts like a diode. That means that no responses can come back after connection initiation."
  // ### Data related associations
  Data             [containingData]       * <-- DataContainment       --> *    [containedData]          Data
      user info: "Data can be contained inside other data."
  Data             [containedData]        * <-- AppContainment        --> *    [containingApp]          Application
      user info: "An application should be able to contain some data."
  Data             [sentData]             * <-- SendData              --> *    [senderApp]              Application
      user info: "An application can also send some data that are supposed to be transferred over a connection. This expresses an active connection."
  Data             [receivedData]         * <-- ReceiveData           --> *    [receiverApp]            Application
      user info: "An application can also receive some data that are supposed to be transferred over a connection. This expresses an active connection."
  Data             [transitData]          * <-- DataInTransit         --> *    [transitNetwork]         Network
      user info: "A network can also contain some data that are supposed to be network-wide available."
  Hardware         [hardware]          0..1 <-- DataHosting           --> *    [hostedData]             Data
      user info: "Data can be hosted on hardware."
  Data             [containerData]        * <-- InfoContainment       --> *    [information]            Information
      user info: "Data can contain information, as for example credentials."
  Data             [dataReplicas]         * <-- Replica               --> *    [replicatedInformation]  Information
      user info: "Information can be replicated across multiple data assets that offer redundancy."
  Data             [encryptedData]        * <-- EncryptionCredentials --> 0..1 [encryptCreds]           Credentials
      user info: "Encrypted data can be associated with the relevant encryption credentials."
  Data             [signedData]           * <-- SigningCredentials    --> 0..1 [signingCreds]           Credentials
      user info: "Signed data can be associated with the relevant signing credentials."
  Credentials      [hashes]               * <-- HashedCredentials     --> 0..1 [origCreds]              Credentials
      user info: "Credentials can be associated with their hashed counterparts. Multiple hashes can be generated for the same Credentials, but a hash is unique to one set of Credentials."
  Credentials      [credentials]          * <-- ConditionalAuthentication --> * [requiredFactors]       Credentials
      user info: "Credentials can be associated with other Credentials to depict conditional authentication procedures, such as multi-factor authentication."
  Data             [originData]        0..1 <-- Origin                --> 0..1 [originSoftwareProduct]  SoftwareProduct
      user info: "Any SoftwareProduct can be associated with Origin Data that represents the source from which this software was obtained." 
  // ### Access Control happens below
  Identity         [identities]           * <-- IdentityCredentials   --> *    [credentials]            Credentials
  Identity         [userIds]              * <-- UserAssignedIdentities--> *    [users]                  User
  Identity         [parentId]             * <-- CanAssume             --> *    [childId]                Identity
      user info: "Starting from a parent Identity, the child Identities can be assumed due to inheritance."
  Group            [memberOf]             * <-- MemberOf              --> *    [groupIds]               Identity
  Group            [parentGroup]          * <-- MemberOf              --> *    [childGroups]            Group
  // Then, Access Control on application level
  IAMObject        [executionPrivIAMs]    * <-- ExecutionPrivilegeAccess       --> * [execPrivApps]     Application
      user info: "Every application executes on a system with privileges of a specified identity on the system. If the application is compromised then the privileges should be compromised."
  IAMObject        [highPrivAppIAMs]      * <-- HighPrivilegeApplicationAccess --> * [highPrivApps]     Application
      user info: "High privilege application access on an Application results in the (full) access/compromise of the application and all the child applications."
  IAMObject        [lowPrivAppIAMs]       * <-- LowPrivilegeApplicationAccess  --> * [lowPrivApps]      Application
      user info: "Low privilege application access on an Application allows only the local interaction with the application and all the specified privileges."
  // Finally, Access control on data
  IAMObject        [readingIAMs]          * <-- ReadPrivileges        --> *    [readPrivData]           Data
  IAMObject        [writingIAMs]          * <-- WritePrivileges       --> *    [writePrivData]          Data
  IAMObject        [deletingIAMs]         * <-- DeletePrivileges      --> *    [deletePrivData]         Data
  // Associations for the Privileges asset
  Identity         [privilegeIdentities]  * <-- HasPrivileges         --> *    [identityPrivileges]     Privileges
  Group            [privilegeGroups]      * <-- HasPrivileges         --> *    [groupPrivileges]        Privileges
      user info: "Identities, Groups, and Privileges may have account management roles for other Identities, Groups, and Privileges."
  IAMObject        [managers]             * <-- AccountManagement     --> *    [managedIAMs]            IAMObject

}
