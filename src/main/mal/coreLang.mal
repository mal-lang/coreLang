/*
 * Copyright 2019-2021 coreLang contributors <https://mal-lang.org/coreLang/contributors.html>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

include "coreVulnerability.mal"
include "SoftwareVulnerability.mal"

category ComputeResources {

    abstract asset Object
      developer info: "An object is the simplest form of an asset that can be compromised by a vulnerability."
    {
      | attemptUseVulnerability
        user info: "Attempt to use the associated vulnerabilities."

      | deny {A}
        user info: "The attacker can deny some or all functionality of an object."

      | bypassAccessControl @hidden {C, I}
        user info: "The attacker can bypass the access control and gain full access after a vulnerability is abused."
    }

    asset System extends Object
      user info: "A system specifies the hardware on which applications can run."
      developer info: "The attacker can DoS everything that is running on it and access (using physical control) on the OS after effort."
    {
      | connect
        user info: "The attacker can connect to the instance, e.g., through a shell, but has not yet authenticated."
        ->  attemptGainFullAccess,
            specificAccess,
            attemptUseVulnerability

      & attemptConnect [HardAndUncertain]
        user info: "If an attacker has physical access on the premises of a System, he could (not always) try to connect to that System."
        modeler info: "The probability and its value are just estimations and are subject to change."
        ->  connect

      & attemptUsePhysicalVulnerability
        user info: "Attempt to use the associated physical vulnerabilities."

      | allPrivilegeAuthenticate @hidden
        developer info: "Entry point attack step from identity."
        ->  attemptGainFullAccess

      | individualPrivilegeAuthenticate @hidden
        developer info: "Entry point attack step from identity."
        ->  specificAccess

      & attemptGainFullAccess @hidden
        developer info: "This is an intermediate step to ensure connection is possible before gaining full access."
        ->  fullAccess

      | fullAccess {C,I,A}
        user info: "Full access on a system allows the compromise or legitimate access on everything/all the privillges of the system: identities, applications, data, etc."
        ->  sysExecutedApps.fullAccess,
            highPrivSysIds.assume,
            lowPrivSysIds.assume,
            highPrivSysGroups.compromiseGroup,
            lowPrivSysGroups.compromiseGroup,
            sysData.attemptAccess

      & specificAccess
        user info: "Specific access only allows the local connection (through localhost) to the hosted applications."
        ->  sysExecutedApps.localConnect

      | attemptSupplyChainAttack
        developer info: "Intermediate attack step to allow for the auditing defence."
        ->  supplyChainAttack

      & supplyChainAttack [VeryHardAndUncertain]
        user info: "Adversaries may perform supply chain compromise to gain control systems environment access by means of infected hardware of firmware."
        developer info: "Based on supply chain attacks in icsLang as designed by Sotirios."
        modeler info: "The probability fucntion and its value is just an estimation! The System supply chain attack represents an attacker being able to tamper with the hardware/firmware before the deployment of the product and not altierations made to the hardware/firmware once it is operating."
        ->  bypassAccessControl

      # supplyChainAuditing
        user info: "Auditing inside the supply chain can detect possible supply chain attacks."
        developer info: "Mitigation based on the supply chain attack mitigation in icsLang as designed by Sotirios."
        ->  supplyChainAttack

      | physicalAccess
        user info: "Attacker has physical access on the location where the system is physically deployed. He could then exploit physical vulnerabilities and attempt to connect to the system."
        ->  deny,
            attemptConnect,
            attemptUsePhysicalVulnerability,
            sysExecutedApps.physicalAccessAchieved

      # hardwareModificationsProtection
        user info: "This defense protects against unauthorized modifications to the hardware of the system that could lead to bypass of access control via e.g. a vulnerability."
        developer info: "But it does not protect against denial of service attacks."
        ->  attemptConnect,
            attemptUsePhysicalVulnerability,
            unsafeUserActivity

      | attemptUnsafeUserActivity
        user info: "Intermediate attack step that allows for the hardware modifications defence to reduce the impact of unsafe user activity."
        ->  unsafeUserActivity

      & unsafeUserActivity
        user info: "A user is performing unsafe actions on the system. This exposes the Applications running on the system. Currently only represents connecting a removable media drive."
        ->  sysExecutedApps.attemptUnsafeUserActivity,
            sysExecutedApps.physicalAccessAchieved

      | deny {A}
        user info: "Denial of service (DoS) attack on a system leads to DoS on all the executed applications."
        ->  sysExecutedApps.deny

      | bypassAccessControl @hidden {C, I}
        user info: "The attacker can bypass the access control and gain full access after being able to connect to the system and a vulnerability is abused."
        ->  fullAccess
    }

    asset SoftwareProduct
      user info: "A software product is a specific type of software/application which can be associated with specific vulnerabilities."
      developer info: "This asset is only introduces in order to imrpove the usability of the language."
    {
      | compromiseApplication
        user info: "If the origin of a software product is compromised (modified maliciously) then the associated application should also be fully compromised."
        ->  softApplications.attemptFullAccessAfterSoftProdCompromise

      | readApplication
        user info: "If the vulnerability has a read imapct, it should propagate that on all the applications."
        ->  softApplications.attemptReadAfterSoftProdVulnerability

      | modifyApplication
        user info: "If the vulnerability has a modify imapct, it should propagate that on all the applications."
        ->  softApplications.attemptModifyAfterSoftProdVulnerability

      | denyApplication
        user info: "If the vulnerability has a deny imapct, it should propagate that on all the applications."
        ->  softApplications.attemptDenyAfterSoftProdVulnerability
    }

    asset Application extends Object
      user info: "An application models pretty much everything that is executed or can execute other applications."
    {
      let allVulnerabilities = vulnerabilities \/ appSoftProduct.softProductVulnerabilities

      let allApplicationConnections = (appConnections \/ outgoingAppConnections \/ ingoingAppConnections)
      let clientApplicationConnections = (appConnections \/ outgoingAppConnections)
      let serverApplicationConnections = (appConnections \/ ingoingAppConnections)

      # disabled [Disabled]
        user info: "If application is disabled it should behave as nonexistent, thus all attack vectors are removed."
        developer info: "This would even allow us to have a much more dynamic and probabilistic aspect on our model and simulations."
        ->  specificAccessFromLocalConnection,
            specificAccessFromNetworkConnection,
            localAccess,
            networkAccess,
            fullAccessAfterSoftProdVulnerability,
            readAfterSoftProdVulnerability,
            modifyAfterSoftProdVulnerability,
            denyAfterSoftProdVulnerability,
            useVulnerability,
            reverseReach

      | attemptUseVulnerability
        user info: "Attempt to use the connected vulnerabilities, when able to locally or via network connect to the application or when local interaction is possible."
        ->  useVulnerability

      & useVulnerability @hidden
        developer info: "Intermediate attack step to model the case where vulnerabilities should not be compromised because application is disabled."
        ->  allVulnerabilities().attemptAbuse,
            attemptSoftwareProductAbuse,
            fullAccessAfterSoftProdVulnerability,
            readAfterSoftProdVulnerability,
            modifyAfterSoftProdVulnerability,
            denyAfterSoftProdVulnerability

      | attemptReverseReach
        developer info: "This attack step needs to be called in order to have reverse reach start propagating from this Application to the rest of the assets."
        modeller info: "No other attack step on the Application asset triggers this attack step which means that it must be explicitly triggered by the modeller if the attacker is assumed to have reverse reachability on it."
        ->  reverseReach

      & reverseReach @hidden
        developer info: "Reverse reach is used to determine whether or not the attacker can be reached by the user."
        ->  networks.attemptReverseReach,
            clientAccessNetworks.attemptReverseReach,
            serverApplicationConnections().attemptReverseReach,
            appExecutedApps.attemptReverseReach,
            unsafeUserActivityWithAttackerInteraction,
            containedData.attemptReverseReach,
            sentData.attemptReverseReach,
            receivedData.attemptReverseReach,
            networkConnectViaResponse

      | localConnect
        user info: "An attacker with low-privilege access on the executing instance is assumed to be able to locally (on the same host i.e. using loopback) interact with the application."
        ->  localAccess,
            specificAccessFromLocalConnection,
            attemptUseVulnerability, // Connection to all possible vulnerabilities that might be connected to the Application
            allVulnerabilities().localAccessAchieved,
            softwareProductVulnerabilityLocalAccessAchieved

      | networkConnect
        user info: "An attacker can connect to any network exposed application and attempt to authenticate or trigger vulnerabilities."
        ->  networkConnectWithoutTriggeringVulnerabilities,
            attemptUseVulnerability, // Connection to all possible vulnerabilities that might be connected to the Application
            allVulnerabilities().networkAccessAchieved,
            softwareProductVulnerabilityNetworkAccessAchieved

      | networkConnectWithoutTriggeringVulnerabilities @hidden
        developer info: "This attack step is used if the network connection occurs via a ConnectionRule that has its payload inspected, in which case the attacker can still authenticate, but they cannot trigger vulnerabilities."
        ->  networkAccess,
            specificAccessFromNetworkConnection

      | accessNetworkAndConnections
        user info: "An attacker is also possible to access the network(s) and connections to which this application is connected to, and perform client-side attacks."
        ->  networks.access,
            clientAccessNetworks.access,
            clientApplicationConnections().attemptConnectToApplications,
            clientApplicationConnections().attemptAccessNetworks

      | attemptNetworkConnectViaResponse
        developer info: "Intermediate attack step to handle defences."
        ->  networkConnectViaResponse

      & networkConnectViaResponse [VeryHardAndUncertain]
        user info: "An attacker may be able to respond to requests submitted by a client application."
        developer info: "Adopted from awsLang."
        modeler info: "The probability and its value are just estimations and are subject to change."
        ->  networkConnect

      & specificAccessFromLocalConnection @hidden
        developer info: "This intermediate step is used to represent that localConnect has happened before being able to get 'specificAccess'. Same as 'localAccess' attack step."
        ->  specificAccess

      & specificAccessFromNetworkConnection @hidden
        developer info: "This intermediate step is used to represent that networkConnect has happened before being able to get 'specificAccess'. Same as 'networkAccess' attack step."
        ->  specificAccess

      | specificAccess
        user info: "This level of access models a low-privilege access and requires all other privileges to be modeled separately."
        developer info: "An attacker with low-privilege access on the executing instance is assumed to be able to locally (on the same host i.e. using loopback) interact with the executed applications."
        ->  appExecutedApps.localConnect, // But also achieve localConnect on all child applications (this is something that needs to be reviewed again at a later stage)
            attemptLocalConnectVulnOnHost,
            attemptUseVulnerability,   // Connection to all possible vulnerabilities that might be connected to the Application
            containedData.attemptAccessFromIdentity, // This also enables the use of compromised identites but only after specificAccess is reached
            sentData.identityAttemptRead, // Both Data sent and received can be read
            receivedData.identityAttemptRead,
            sentData.attemptIdentityWriteDataInTransitFromApplication,
            clientApplicationConnections().attemptAllowWriteDataInTransit, // Only data in transit that initiate from this Application can be written
            clientApplicationConnections().attemptAllowDenyDataInTransit,  // or denied
            attemptApplicationRespondConnectThroughData,
            accessNetworkAndConnections  // and access the network(s) and connections on/to which the app is connected

      | attemptLocalConnectVulnOnHost [HardAndUncertain]
        user info: "The attacker is able to break out of an application container/sandbox and try to exploit any vulnerability of the hypervisor/host application"
        modeler info: "The probability and its value are just estimations and are subject to change."
        ->  hostApp.attemptUseVulnerability

      | authenticate
        user info: "The attacker is able to authenticate with the appropriate credentials."
        ->  localAccess,
            networkAccess,
            allVulnerabilities().highPrivilegesAchieved,
            softwareProductVulnerabilityHighPrivilegesAchieved

      | specificAccessAuthenticate
        user info: "The attacker is able to authenticate with the appropriate specific access credentials."
        ->  specificAccessFromLocalConnection,
            specificAccessFromNetworkConnection,
            allVulnerabilities().lowPrivilegesAchieved,
            softwareProductVulnerabilityLowPrivilegesAchieved

      & localAccess @hidden
        developer info: "Intermediate attack steps for modeling the two requirements (reachabiltiy and authentication) for access."
        ->  fullAccess

      & networkAccess @hidden
        developer info: "Intermediate attack steps for modeling the two requirements (reachabiltiy and authentication) for access."
        ->  fullAccess

      | fullAccess {C,I,A}
        user info: "Legitimate (or not i.e. 0wned) full access on the Application, as root/administrator."
        ->  read,
            modify,
            deny,
            appExecutedApps.fullAccess, // Gain access on all applications executed by this (host) application
            executionPrivIds.assume,  // Assume also the execution privilege identities of this application
            executionPrivGroups.compromiseGroup,
            containedData.attemptAccess,  // and access on all the contained data
            sentData.attemptRead, // Both Data sent and received can be read
            receivedData.attemptRead,
            sentData.attemptWriteDataInTransitFromApplication,
            clientApplicationConnections().attemptAllowWriteDataInTransit, // Only data in transit that initiate from this Application can be written
            clientApplicationConnections().attemptAllowDenyDataInTransit,  // or denied
            attemptApplicationRespondConnectThroughData,
            accessNetworkAndConnections,  // and access the network(s) and connections on/to which the app is connected
            hostApp.localConnect,    // and localConnect on the host application
            managedRoutingFw.fullAccess, // if the routing firewall manager app is compromised the routing firewall should also be compromised
            specificAccess // And also provide specificAccess, mainly for completeness and more intuitive results

      | physicalAccessAchieved @hidden
        developer info: "Intermediate attack step used to propagate physical access throughout application nesting."
        ->  allVulnerabilities().physicalAccessAchieved,
            softwareProductVulnerabilityPhysicalAccessAchieved,
            appExecutedApps.physicalAccessAchieved

      | attemptUnsafeActivityByUser @hidden
        developer info: "Intermediate attack step."
        ->  unsafeActivityByUser

      & unsafeActivityByUser
        user info: "The unsafe actions of users on this application open it up to attacks and enable vulnerabilities that require user interaction."
        ->  localConnect,
            networkConnect,
            allVulnerabilities().userInteractionAchieved

      & unsafeUserActivityWithAttackerInteraction @hidden
        developer info: "The attacker can be reached from this application and can therefore more easily exploit the unsafe user actions."
        ->  attemptUnsafeActivityByUser

      | unsafeUserActivityWithoutAttackerInteraction @hidden [VeryHardAndUncertain]
        developer info: "The attacker cannot be reached from this application. This means that the autonomous malicious code must either be able to do reconnaissance on the fly or the reconnaissance was done before and coded into it. This is much more complex and difficult than the situation where the attacker is reachable from the application. Important Note: This step should never directly or indirectly lead to reverse reach as it would fulfil the attacker interactivity requirements its counterpart is missing."
        ->  attemptUnsafeActivityByUser

      | attemptUnsafeUserActivity @hidden
        developer info: "This attack step represents a user with privileges on this application engaging in unsafe behaviour that could lead to exposing the application to the attacker."
        ->  unsafeUserActivityWithAttackerInteraction,
            unsafeUserActivityWithoutAttackerInteraction

      # supplyChainAuditing
        user info: "Auditing inside the supply chain can detect possible supply chain attacks."
        developer info: "Mitigation based on the hardware/firmware supply chain attack mitigation in icsLang as designed by Sotirios."
        ->  fullAccessAfterSoftProdCompromise

      | attemptFullAccessAfterSoftProdCompromise @hidden
        developer info: "Intermediate attack step."
        ->  fullAccessAfterSoftProdCompromise

      & fullAccessAfterSoftProdCompromise @hidden
        developer info: "Intermediate attack step."
        ->  fullAccess

      // Intermediate attack steps to allow SoftwareProduct Vulnerabilities to only happen after each Applications is reached by the attacker.
      | attemptFullAccessAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  fullAccessAfterSoftProdVulnerability

      | attemptReadAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  readAfterSoftProdVulnerability

      | attemptModifyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  modifyAfterSoftProdVulnerability

      | attemptDenyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step."
        ->  denyAfterSoftProdVulnerability

      E softwareCheck @hidden
        user info: "Existence attack step to only allow the connected attacks steps only if a SoftwareProduct is associated."
        <- appSoftProduct
        -> fullAccessAfterSoftProdVulnerability,
           readAfterSoftProdVulnerability,
           modifyAfterSoftProdVulnerability,
           denyAfterSoftProdVulnerability

      | softwareProductVulnerabilityLocalAccessAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> appSoftProduct.softProductVulnerabilities.localAccessAchieved,
           softwareProductAbuse

      | softwareProductVulnerabilityNetworkAccessAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> appSoftProduct.softProductVulnerabilities.networkAccessAchieved,
           softwareProductAbuse

      | softwareProductVulnerabilityPhysicalAccessAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> appSoftProduct.softProductVulnerabilities.physicalAccessAchieved,
           softwareProductAbuse

      | softwareProductVulnerabilityLowPrivilegesAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> appSoftProduct.softProductVulnerabilities.lowPrivilegesAchieved,
           softwareProductAbuse

      | softwareProductVulnerabilityHighPrivilegesAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> appSoftProduct.softProductVulnerabilities.highPrivilegesAchieved,
           softwareProductAbuse

      | softwareProductVulnerabilityUserInteractionAchieved @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> appSoftProduct.softProductVulnerabilities.userInteractionAchieved,
           softwareProductAbuse

      | attemptSoftwareProductAbuse @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> softwareProductAbuse

      & softwareProductAbuse @hidden
        developer info: "Intermediate attack step used to conditionally trigger SoftwareProduct vulnerabilities separately for each application."
        -> fullAccessAfterSoftProdVulnerability,
           readAfterSoftProdVulnerability,
           modifyAfterSoftProdVulnerability,
           denyAfterSoftProdVulnerability


      & fullAccessAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  fullAccess

      & readAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  read

      & modifyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  modify

      & denyAfterSoftProdVulnerability @hidden
        developer info: "Intermediate attack step to handle existence."
        ->  deny

      | attemptApplicationRespondConnectThroughData @hidden
        user info: "After access on the application the contained data or data in transit can be used to attempt a respond connect to the client side application."
        modeler info: "This is an intermediate attack step that groups connections to attack steps."
        ->  receivedData.attemptApplicationRespondConnect

      | read {C}
        user info: "The attacker can read some or all of this service's code and data."
        developer info: "We don't model the services data, as we do not expect that information will be available to the parser. We also don't differentiate between service administrators and service users (e.g., mail service admins and users), as we have no information about the services. Adopted from awsLang."
        ->  containedData.attemptRead

      | modify {I}
        user info: "The attacker can modify some or all of this service's data and/or source code."
        ->  containedData.attemptAccess,
            fullAccess

      | deny {A}
        user info: "The attacker can deny some or all functionality and data pertaining to this application/service as well as executed applications."
        ->  containedData.attemptDeny,
            sentData.attemptDenyDataInTransitFromApplication,
            appExecutedApps.deny

      & denyFromNetworkingAsset @hidden
        user info: "This is an intermediate attack step to only allow deny on an application when all the connection rules and networks associated with it are denied, because an app can be serving on many different ports."
        -> deny

    }

    asset IDPS extends Application
      user info: "An IDPS is tasked with protecting other applications from malicious activity."
    {
      # effectiveness [Enabled]
        user info: "The effectiveness defence reprents how capable the IDPS is to prevent disruptions from occuring on the associated applications."
        modeller info: "The disabled defence should inversely impact the effectiveness defence. However, because this is not currently implemented in coreLang it is up to the modeller to properly take this into account when setting the values of these defences."
        ->  protectionBypassed

      # disabled @Override @hidden [Disabled]
        modeller info: "As per the comment for the effectiveness defence, the disabled defence does not function as desired for the IDPS asset and should not be used. The effectiveness defence should be adjusted to reflect the likelihood that the IDPS is present instead."
        developer info: "It would be ideal to hide this defence when using modelling tools to avoid confusion."

      | protectionBypassed @hidden
        developer info: "The protection of the IDPS has been bypassed either as a result of attacker activity or due to some internal property of the IDPS."
        ->  protectedApps.useVulnerability, // The IDPS is no longer able to protect the apps assigned to it
            protectedApps.unsafeActivityByUser


      | fullAccess {C,I,A}
        +>  protectionBypassed // The application is no longer able to protect the apps assigned to it

    }

    asset PhysicalZone
      user info: "A physical zone is the location where systems are physically deployed."
    {
      | gainPhysicalAccess
        user info: "By gaining access on a physical zone, physical access on the housed systems is also gained."
        ->  systems.physicalAccess
    }
}

category DataResources {

    asset Information
      user info: "Represents any type of information that might be contained inside Data."
    {
      | attemptAccess
        user info: "The attacker is attempting to access the information."

      | read
        user info: "Reading one replica allows the attacker to read all other replicas as well since the information contained in them is the same."
        ->  dataReplicas.read

      & write
        user info: "Information can be overwritten only if all replicas have been overwritten."

      & delete
        user info: "Information can be deleted only if all replicas have been deleted."

      & deny
        user info: "Information can be denied only if all replicas have been denied."
    }

    asset Data
      user info: "Any form of data that can be stored or transmitted."
      developer info: "Adopted from awsLang but significantly changed."
    {
        | attemptAccess
          user info: "Attempt to access the data, this might fail if the 'dataNotPresent' defense is used."
          ->  access

        | attemptAccessFromIdentity
          user info: "Access the data through a compormised identity."
          ->  identityRead,
              identityWrite,
              identityDelete

        & access
          user info: "Access the data."
          ->  attemptRead,
              attemptWrite,
              attemptDelete,
              containedData.attemptAccess

        !E dataEncrypted @hidden
          user info: "If the data are encrypted then accessing them requires the associated encryption credentials/key."
          developer info: "Data will be considered as encrypted if there is at least one Credentials instance associated with it. Otherwise, 'accessUnencryptedData' is reached."
          <-  encryptCreds
          ->  accessUnencryptedData

        !E dataSigned @hidden
          user info: "If the data are authenticated, then modifying them is not possible to achieve."
          developer info: "Data will be considered as encrypted if there is at least one Credentials instance associated with it. Otherwise, 'accessUnencryptedData' is reached."
          <-  signingCreds
          ->  accessUnsignedData

        & accessUnencryptedData @hidden
          user info: "If data are unencrypted then access them."
          ->  accessDecryptedData

        & accessUnsignedData @hidden
          user info: "If data are unsigned then alter them."
          ->  accessSpoofedData

        | accessSpoofedData @hidden
          user info: "Intermediate attack step to only allow effects of 'accessUnsignedData' on data after compromising the signing credentials or signing is disabled."
          ->  containedData*.applicationRespondConnect,
              containedData*.successfulWrite,
              containedData*.manInTheMiddle

        | accessDecryptedData @hidden
          user info: "Intermediate attack step to only allow effects of 'accessUnencryptedData' on data after compromising the encryption credentials or encryption is disabled."
          ->  access,
              readContainedInformation,
              applicationRespondConnect,
              eavesdrop,
              manInTheMiddle,
              successfulRead,
              successfulWrite,
              successfulDelete

        # dataNotPresent [Disabled]
          user info: "It should be used to model the probability of data actually not existing on the connected container (i.e. System, Application, Connection, etc.)."
          developer info: "This attack step is in series with the 'accessUnencryptedData' attack step because there is no reason to defend encrypted data (or deny them) if they do not exist..."
          ->  accessUnencryptedData,
              successfulDeny

        & readContainedInformation
          user info: "From the data, attempt to access also the contained information, if exists."
          ->  information.attemptAccess

        | overrideCredentials @hidden
          developer info: "If the attacker is able to write the data containing credentials we assume that they are able to override the authentication mechanisms where those credentials are used."
          ->  information[Credentials].attemptAccess

        | attemptApplicationRespondConnect @hidden
          developer info: "Intermediate attack step to handle defenses."
          ->  applicationRespondConnect

        & applicationRespondConnect
          user info: "If data is manInTheMiddled or the server side application is compromised, then respond connect to the client side application can be done."
          ->  senderApp.attemptNetworkConnectViaResponse

        | attemptRead @hidden
          user info: "Attempt to read the data."
          ->  successfulRead

        | identityAttemptRead @hidden
          user info: "Attempt to read the data through a compormised identity."
          ->  identityRead

        & identityRead @hidden
          developer info: "Intermediate attack step to only allow operations on data after both access and identity assume is compromised."
          ->  attemptRead

        | attemptWrite @hidden
          user info: "Attempt to write on the data."
          ->  successfulWrite

        | identityAttemptWrite @hidden
          user info: "Attempt to write the data through a compormised identity."
          ->  identityWrite

        & identityWrite @hidden
          developer info: "Intermediate attack step to only allow operations on data after both access and identity assume is compromised."
          ->  attemptWrite

        | attemptDelete @hidden
           user info: "Attempt to delete the data."
          -> successfulDelete

        | identityAttemptDelete @hidden
          user info: "Attempt to delete the data through a compormised identity."
          ->  identityDelete

        & identityDelete @hidden
          developer info: "Intermediate attack step to only allow operations on data after both access and identity assume is compromised."
          ->  attemptDelete

        & successfulRead @hidden
          developer info: "Intermediate attack step to model the requirements."
          ->  read

        | read {C}
          user info: "The attacker can read the data. This means that the data can be used for further attack steps, but they are not necessarily obtained by the attacker. The extract attack step covers the scenario where the attacker actually collects the data."
          ->  containedData.attemptRead,
              readContainedInformation,
              replicatedInformation.read,
              extract

        & successfulWrite @hidden
          developer info: "Intermediate attack step to model the requirements."
          ->  replicatedInformation.write,
              write

        | write {I}
          user info: "The attacker can write to the location of the data, effectively modifying or deleting it."
          ->  containedData.attemptWrite,
              attemptDelete,
              compromiseAppOrigin,
              overrideCredentials

        & successfulDelete @hidden
          developer info: "Intermediate attack step to model the requirements."
          ->  replicatedInformation.delete,
              delete

        | delete {I,A}
          user info: "The attacker can delete the data."
          ->  containedData.attemptDelete,
              attemptDeny

        | attemptDeny @hidden
          developer info: "Intermediate attack step to only allow deny on data after only if 'dataNotPresent' defense is disabled."
          ->  successfulDeny

        & successfulDeny @hidden
          developer info: "Intermediate attack step to model the requirements."
          ->  replicatedInformation.deny,
              deny

        | deny {A}
          user info: "If a DoS is performed data are denied, it has the same effects as deleting the data."
          ->  containedData.attemptDeny

        | attemptEavesdrop @hidden
          developer info: "Intermediate attack step to only allow eavesdrop on data after all defenses are disabled."
          ->  eavesdrop

        | attemptManInTheMiddle @hidden
          developer info: "Intermediate attack step to only allow MitM on data after all defenses are disabled."
          ->  manInTheMiddle

        & eavesdrop {C}
          user info: "Evasdrop on Data could lead to read access on unencrypted Data."
          ->  attemptRead

        & manInTheMiddle {C, I}
          user info: "MitM on Data could lead to read and write access on unencrypted and unauthenticated Data."
          ->  attemptRead,
              attemptWrite,
              attemptApplicationRespondConnect

        | attemptWriteDataInTransitFromApplication @hidden
          developer info: "Intermediate attack step to allow data in transit to be written from the Application side."
          ->  writeDataInTransit

        | attemptIdentityWriteDataInTransitFromApplication @hidden
          developer info: "Intermediate attack step to allow data in transit to be written if the Identity associated is also compromised from the Application side."
          ->  identityWriteDataInTransit

        | attemptWriteDataInTransitFromConnectionRule @hidden
          developer info: "Intermediate attack step to allow data in transit to be written from the ConnectionRule side."
          ->  writeDataInTransit,
              identityWriteDataInTransit

        & identityWriteDataInTransit @hidden {C, I}
          developer info: "For Data in transit to be witten via an Application they have to be reachable from an outgoing ConnectionRule as well."
          ->  identityAttemptWrite

        & writeDataInTransit @hidden {C, I}
          developer info: "For Data in transit to be witten via an Application they have to be reachable from an outgoing ConnectionRule as well."
          ->  attemptWrite

        | attemptDenyDataInTransitFromApplication @hidden
          developer info: "Intermediate attack step to allow data in transit to be denied from the Application side."
          ->  denyDataInTransit

        | attemptDenyDataInTransitFromConnectionRule @hidden
          developer info: "Intermediate attack step to allow data in transit to be denied from the ConnectionRule side."
          ->  denyDataInTransit

        & denyDataInTransit @hidden {C, I}
          developer info: "For Data in transit to be denied via an Application they have to be reachable from an outgoing ConnectionRule as well."
          ->  attemptDeny

        | attemptReverseReach @hidden
          developer info: "Intermediate attack step."
          ->  reverseReach

        & reverseReach @hidden
          developer info: "Reverse reach for Data is used to determine whether or not the data can be transferred to attacker."
          ->  extract,
              containedData.attemptReverseReach

        & extract
          user info: "The attacker can extract the data. The read attack step represents just being able to make use of the data for further attack steps without the attacker obtaining it."
          ->  information.read

        | compromiseAppOrigin
          user info: "If origin data are modified/written then the software product is also compromised which effectively also compromises the application."
          ->  originSoftwareProduct.compromiseApplication
    }
}

category IAM {

    asset Identity
      user info: "An identity models an IAM identity that should then be associated with privileges on other instances."
      developer info: "An identity can be visualised as a group of assumable roles that can be associated with many credentials."
    {
        # disabled [Disabled]
        user info: "It should be used to model the probability that the identity is actually not existing."
          ->  successfulAssume

        | attemptAssume
          user info: "Attempt to assume the identity."
          ->  successfulAssume

        & successfulAssume @hidden
          developer info: "Intermediate attack step to model the requirements for identity assume."
          ->  assume

        | assume {C,I,A}
          user info: "After authentication or compromise of an account/identity, assume its privileges."
          developer info: "This is both legitimate and illegitimate access! Also assume all the privileges of the parent identities (on the above level/inherited by this identity) because those represent the group of (inherited) roles."
          ->  parentId.assume,
              memberOf.compromiseGroup,
              identityPrivileges.attemptAssume,
              lowPrivManagedSystems.individualPrivilegeAuthenticate,
              highPrivManagedSystems.allPrivilegeAuthenticate,
              execPrivApps.authenticate,
              highPrivApps.authenticate,
              lowPrivApps.specificAccessAuthenticate,
              readPrivData.identityAttemptRead,
              writePrivData.identityAttemptWrite,
              deletePrivData.identityAttemptDelete
    }

    asset Privileges
      user info: "A privileges asset can be associated with an identity to group a set of given privileges on Applications and Data."
    {
        # disabled [Disabled]
        user info: "It should be used to model the probability that the set of privileges is actually not existing."
          ->  assume

        | attemptAssume
          user info: "Attempt to assume the privileges. If disabled this will not be possible."
          ->  assume

        & assume
          ->  execPrivApps.authenticate,
              highPrivApps.authenticate,
              lowPrivApps.specificAccessAuthenticate,
              readPrivData.identityAttemptRead,
              writePrivData.identityAttemptWrite,
              deletePrivData.identityAttemptDelete
    }

    asset Group
      user info: "A group is a way to group together identities and/or groups. This allows the expression of hierarchical IAM (structured inheritance)."
      modeler info: "Groups can be used instead of nested identities to make the model more intuitive and clearer to understand."
    {
      | compromiseGroup {C}
        user info: "If an identity of a group is compromised then the whole group (i.e. all other privileges of the group) should be considered as compromised. Furthermore, the parent groups should also be considered compromised."
        developer info: "The parent groups should be compromised because all the privileges of the parent groups are inherited on the children groups but lower children groups should not be compromised because lower levels might have inherited plus additional privileges."
        ->  parentGroup.compromiseGroup,
            lowPrivManagedSystems.individualPrivilegeAuthenticate,
            highPrivManagedSystems.allPrivilegeAuthenticate,
            execPrivApps.authenticate,
            highPrivApps.authenticate,
            lowPrivApps.specificAccessAuthenticate,
            readPrivData.identityAttemptRead,
            writePrivData.identityAttemptWrite,
            deletePrivData.identityAttemptDelete
    }

    asset Credentials extends Information
      user info: "A credential is used to get access as an Identity but it can also be used as an encryption key for Data."
    {
      # notDisclosed [Enabled]
        user info: "Describes the case where the password/credential is leaked to some location, it can then be available to the attacker."
        ->  useLeakedCredentials

      # notGuessable [Enabled]
        user info: "Describes if the credentials can be guessed by the attacker(e. g. they represent a password or passphrase)."
        ->  guessCredentials

      # unique [Enabled]
        user info: "Describes if the credentials are known to be unique and therefore cannot be used in a credentials reuse attack."
        ->  credentialsReuse,
            propagateOneCredentialCompromised

      # notPhishable [Disabled]
        user info: "Describes if the credentials cannot be phished(they are biometric, e. g. fingerprints or iris scans, or physical, e. g. access cards or keys, elements)."
        ->  credentialTheft

      & write @Override
        developer info: "If the attacker is able to write the information containing credentials we assume that they are able to override the authentication mechanisms where those credentials are used."
        +> attemptUse

      | read @Override
        developer info: "If the attacker is able to read the information containing credentials we assume that they are compromised."
        +> attemptUse

      | useLeakedCredentials [EasyAndCertain]
        user info: "If the password/credential is leaked to some location, it can then be available to the attacker and therefore it can be used."
        ->  attemptUse

      | attemptCredentialsReuse @hidden
        developer info: "Intermediate step used to trigger the reuse attack step on other credentials belonging to the same user."
        ->  credentialsReuse,
            requiredFactors.attemptCredentialsReuse

      & credentialsReuse
        developer info: "The user is reusing credentials which means that the attacker is able to compromise all of the non-unique credentials associated with this user."
        ->  attemptUse

      | attemptUse
        user info: "Someone is using the credentials to perform a legitimate authentication."
        ->  use

      & use {C}
        user info: "Someone is using the credentials to perform a legitimate authentication."
        ->  identities.attemptAssume,
            encryptedData.accessDecryptedData,
            signedData.accessSpoofedData,
            attemptPropagateOneCredentialCompromised,
            credentials.use,
            hashes.attemptUse,
            origCreds.guessCredentialsFromHash

      | attemptPropagateOneCredentialCompromised @hidden
        developer info: "Intermediate step used to propagate the credentials reuse attack step."
        ->  propagateOneCredentialCompromised

      & propagateOneCredentialCompromised @hidden
        developer info: "Intermediate step used to propagate the credentials reuse attack step."
        ->  credentials*.identities.users.oneCredentialCompromised

      | attemptAccess
        user info: "The attacker is attempting to access the credentials."
        ->  attemptUse

      | attemptCredentialTheft @hidden
        developer info: "Intermediate step used to trigger the credential theft attack step."
        ->  credentialTheft,
            requiredFactors.attemptCredentialTheft

      & credentialTheft
        user info: "The attacker is able to steal the credentials."
        ->  attemptUse

      | weakCredentials @hidden
        developer info: "Intermediate step used to represent how weak the credentials the user employs are. This is inversely related to the securityAwareness defence on the User asset."
        ->  guessCredentials,
            requiredFactors.weakCredentials

      !E credsHashed @hidden
          developer info: "If there are no associated hashes the assumption is that the credentials are guessable without any additional requirements."
          <-  hashes
          ->  guessCredentialsFromHash

      | guessCredentialsFromHash @hidden
          developer info: "If hashes are associated with this Credentials asset the assumption is that one of those hashes is required by the attacker to be able to perform a guessing attack."
        ->  guessCredentials

      & guessCredentials [HardAndUncertain]
        user info: "The attacker can attempt to just guess a set of credentials. The likelihood of succeeding is depend on how strong the credentials are."
        developer info: "We should research the probability we want to use for this attack step more."
        ->  attemptUse

    }
}

category User {

    asset User
      user info: "This asset represents the user himself. It is the suitable attack surface for social engineering attacks!"
    {
        # noPasswordReuse [Enabled]
          user info: "If one credential of that user is compromised there is a probability that all other credentials of that user are also compromised."
          ->  passwordReuseCompromise

        # securityAwareness
          user info: "The security awareness of the user makes it less likely that social engineering would be successful and reduces the likelihood that the user will engage in unsafe behaviour."
          ->  socialEngineering,
              unsafeUserActivity,
              weakCredentials,
              deliverMaliciousRemovableMedia

        | oneCredentialCompromised @hidden
          developer info: "This intermediate attack step is needed in order to block passwordReuseCompromise when no other credential is first compromised."
          ->  passwordReuseCompromise

        & passwordReuseCompromise
          user info: "If one reused credential of that user is compromised then, all other credentials of that user can also be compromised."
          ->  userIds.credentials.attemptCredentialsReuse

        | weakCredentials @hidden
          user info: "Intermediate attack step that defines the strength of all of the Credentials associated with the user. This is inversely proportional with the user's securityAwareness defence."
          ->  userIds.credentials.weakCredentials

        | attemptSocialEngineering
          user info: "Intermediate attack step that allows for security awareness to reduce the impact of social engineering operations."
          ->  socialEngineering

        & socialEngineering @hidden
          user info: "An attacker can try to perform social engineering techniques such as phishing."
          developer info: "In the future, other social engineering techniques should be connected to this attack step."
          ->  phishUser,
              unsafeUserActivity

        | attemptDeliverMaliciousRemovableMedia
          user info: "Intermediate attack step that allows for security awareness to reduce the impact of delivering malicious removable media."
          ->  deliverMaliciousRemovableMedia

        & deliverMaliciousRemovableMedia [Exponential(0.01)]
          user info: "An attacker can try to deliver a removable media drive(e.g. USB drive) containing malicious code to a location accessible to the target users."
          developer info: "The probability distribution is entirely arbitrary and should be researched in greater detail."
          ->  userIds.attemptAssume,
              userIds.highPrivManagedSystems.attemptUnsafeUserActivity,
              userIds.lowPrivManagedSystems.attemptUnsafeUserActivity

        | phishUser
          user info: "The attacker can phish the user to gain access to their credentials."
          ->  attemptCredentialTheft

        | attemptCredentialTheft @hidden
          user info: "Trick the user to provide his/her credentials."
          ->  credentialTheft

        | credentialTheft [HardAndUncertain]
          developer info: "This attack is hard to happen."
          modeler info: "Distribution: Bernoulli(0.5) * Exponential(0.1), source: Sommestad (2011) Password authentication attacks: a survey of attacks and when they will succeed, suggest to use Bernoulli(0.05)"
          ->  userIds.credentials.attemptCredentialTheft

        & unsafeUserActivity [Exponential(0.03)]
          developer info: "The user can engage in unsafe behaviour that could allow the attacker to gain access to the applications the user has access to."
          modeler info: "An attacker may trigger the assume step on identities belonging to the user without being able to reach (or be reached) via any of the Applications that the identity has access to. This represents an unmaterialised threat in that scenario. The choice of probability is entirely arbitrary and should be replaced with a scientifically grounded distribution."
          ->  userIds.attemptAssume,
              userIds.execPrivApps.attemptUnsafeUserActivity,
              userIds.identityPrivileges.execPrivApps.attemptUnsafeUserActivity,
              userIds.highPrivApps.attemptUnsafeUserActivity,
              userIds.identityPrivileges.highPrivApps.attemptUnsafeUserActivity,
              userIds.lowPrivApps.attemptUnsafeUserActivity,
              userIds.identityPrivileges.lowPrivApps.attemptUnsafeUserActivity

    }
}

category Networking {

    asset Network
      user info: "A network (zone) is a set of network accessible applications and data."
      developer info: "The network asset tries to cover all the levels of the OSI stack in a very abstract and compact way (i.e. it tries to represent all the OSI layers). For example it will try to cover both ARP attacks (that are Level 2) but also DNS/HTTP spoofing attacks (that are Level 7)."
    {
      let allNetApplications = (clientApplications \/ applications)
      let allowedNetworkConnections =  netConnections \/ outgoingNetConnections
      let allowedApplicationConnections = (netConnections \/ outgoingNetConnections)
      let allNetConnections = netConnections \/ ingoingNetConnections \/ outgoingNetConnections \/ diodeIngoingNetConnections
      let allowedApplicationConnectionsApplications = allNetApplications() \/ allNetConnections().applications

      | physicalAccess {C, A}
        developer info: "Attacker has physical access on the network. This means he can cut wires/fibers, connect using iLOs, eavesdrop and get proper network access."
        ->  denialOfService,
            eavesdropAfterPhysicalAccess,
            attemptAccess,
            bypassAccessControl

      # networkAccessControl
        user info: "Access control protects from unauthorized physical access on the network."
        ->  eavesdropAfterPhysicalAccess,
            attemptAccess

      | bypassAccessControl [VeryHardAndUncertain]
        user info: "If access control is enabled, the attacker can still try to bypass it and gain access on the network."
        ->  successfulAccess

      & attemptAccess @hidden
        user info: "Access on a Network can be atempted after physicalAccess."
        ->  access

      | access
        user info: "Access provides connect to all reachable applications."
        ->  successfulAccess

      | successfulAccess @hidden
        developer info: "This is an intermediate attack step to prevent repeating code."
        ->  allowedApplicationConnections().attemptConnectToApplications,
            applications.networkConnect,
            clientApplications.attemptNetworkConnectViaResponse,
            accessNetworkData,
            networkForwarding,
            denialOfService,
            attemptReverseReach

      | attemptReverseReach @hidden
        developer info: "Intermediate attack step."
        ->  reverseReach

      & reverseReach @hidden
        developer info: "Reverse reach is used to determine whether or not the attacker can be reached by the user."
        ->  (netConnections \/ ingoingNetConnections \/ diodeIngoingNetConnections).attemptReverseReach,
            clientApplications.attemptReverseReach,
            applications.attemptReverseReach

      | networkForwarding
        developer info: "By using the allowed connections (connection rules), forwarding from one network to another network or applications can happen."
          ->  allowedNetworkConnections().attemptAccessNetworks,
              allowedNetworkConnections().attemptConnectToApplications

      | denialOfService {A}
        user info: "If a DoS is performed it affects, the applications communicating over the network as well as the connected application."
        ->  allNetConnections().attemptDenialOfService,
            allowedApplicationConnectionsApplications().denyFromNetworkingAsset

      | accessNetworkData
        user info: "Access also the data that are network-wide available."
        ->  eavesdrop,
            bypassEavesdropProtection,
            manInTheMiddle,
            bypassMitMProtection

      # eavesdropDefense
        user info: "This defense protects from eavesdrop attacks. If this defense is disabled, then it is equivalent to the network being considered a broadcast network."
        modeler info: "If this defense is enabled, attacks such as ARP spoofing should however, still be possible. This can be done by assigning a Bernoulli distribution to this defense."
        ->  eavesdrop,
            eavesdropAfterPhysicalAccess

      # manInTheMiddleDefense
        user info: "This defense protects against man-in-the-middle (MitM) attacks that are originating either form the network layer (like ARP spoofing) or by manipulating the higher network layers (like DNS poisoning)."
        ->  manInTheMiddle

      & eavesdrop {C}
        user info: "An attacker that performs an eavesdrop attack on a network tries to access all the transfered data over that network."
        ->  successfulEavesdrop

      | bypassEavesdropProtection {C} [HardAndUncertain]
        user info: "The eavesdrop protection can be bypassesed."
        ->  successfulEavesdrop

      | successfulEavesdrop @hidden
        developer info: "This is an intermediate attack step to prevent repeating code."
        ->  transitData.attemptEavesdrop

      & manInTheMiddle {C, I}
        user info: "An attacker that performs a MitM attack on a network tries to read and modify all the transfered data over that network."
        ->  successfulManInTheMiddle

      | bypassMitMProtection {C, I} [HardAndUncertain]
        user info: "The MitM protection can be bypassesed."
        ->  successfulManInTheMiddle

      | successfulManInTheMiddle @hidden
        developer info: "This is an intermediate attack step to prevent repeating code."
        ->  transitData.attemptManInTheMiddle

      & eavesdropAfterPhysicalAccess @hidden {C}
        user info: "If a network is not a switching network and the attacker has physical access on it, eavesdrop can happen."
        ->  successfulEavesdrop
    }

    asset RoutingFirewall extends Application
      user info: "A routing firewall specifies a router with firewall capabilities that connects many networks."
    {
      | denialOfService {A}
       user info: "A DoS attack should cascade on the connected networks and associated connections"
        ->  connectionRules.attemptDenialOfService

      | fullAccess {I, A}
        developer info: "If full access is achieved on RoutingFirewall then it is 0wned and all connections can be allowed! This can happen by compromising the manager application."
        +>  (connectionRules.networks \/ connectionRules.outNetworks \/ connectionRules.inNetworks \/ connectionRules.diodeInNetworks).access,
            connectionRules.applications.networkConnect
    }

    asset ConnectionRule
      user info: "This asset is used to model firewall rules between Applications and/or Networks. The association selected (bi/uni-directional) only describes the connection initiation."
      developer info: "This asset is mainly used to model the functionality of a network connection through a firewall. If Data is added, then it also models the data in transit."
    {
      let allApplications = (applications \/ inApplications \/ outApplications)
      let clientApplications = (applications \/ outApplications)
      let serverApplications = (applications \/ inApplications)

      # restricted [Disabled]
        user info: "The restricted defence can be used to probabilistically model the likelihood of both the protocols required by the attack being enabled or the existence of the ConnectionRule altogether."
        ->  accessNetworks,
            connectToApplications,
            connectToApplicationsWithoutTriggeringVulnerabilities,
            denialOfService,
            allowWriteDataInTransit,
            allowDenyDataInTransit,
            reverseReach

      # payloadInspection [Disabled]
        user info: "If enabled, then the traffic is considered to be inspected and filtered by an IDPS that can detect and stop malicious payloads, effectively allowing only legitimate communication(i. e. network-level vulnerabilities cannot be exploited)."
        ->  connectToApplications,
            reverseReach

      // All the hidden attack steps below are hidden because they are just used for the internal mechanics of the ConnectionRules
      | attemptReverseReach @hidden
        developer info: "Intermediate attack step."
        ->  reverseReach

      & reverseReach @hidden
        developer info: "Reverse reach is used to determine whether or not the attacker can be reached by the user."
        ->  clientApplications().attemptReverseReach,
            (networks \/ outNetworks).attemptReverseReach

      | attemptAccessNetworks @hidden
        developer info: "Intermediate attack step."
        ->  accessNetworks

      & accessNetworks
        developer info: "Access all networks that are associated with this ConnectionRule."
        ->  (networks  \/ inNetworks  \/ diodeInNetworks).access

      | attemptConnectToApplications @hidden
        developer info: "Intermediate attack step."
        ->  connectToApplications,
            connectToApplicationsWithoutTriggeringVulnerabilities

      & connectToApplications @hidden
        developer info: "Connect to all the (server) Applications that are associated with this ConnectionRule."
        ->  serverApplications().networkConnect

      & connectToApplicationsWithoutTriggeringVulnerabilities @hidden
        developer info: "Connect to all the (server) Applications that are associated with this ConnectionRule, but without triggering vulnerabilities on them. This attack step is used to allow legitimate traffic even when payload inspection is enabled on the connection."
        ->  serverApplications().networkConnectWithoutTriggeringVulnerabilities

      | attemptDenialOfService @hidden
        developer info: "Intermediate attack step."
        ->  denialOfService

      & denialOfService {A}
        ->  allApplications().denyFromNetworkingAsset

      | attemptAllowWriteDataInTransit @hidden
        developer info: "Intermediate attack step."
        ->  allowWriteDataInTransit

      & allowWriteDataInTransit @hidden
        developer info: "Only trigger write on Data in transit on client connections."
        ->  (networks  \/ inNetworks  \/ diodeInNetworks).transitData.attemptWriteDataInTransitFromConnectionRule

      | attemptAllowDenyDataInTransit @hidden
        developer info: "Intermediate attack step."
        ->  allowDenyDataInTransit

      & allowDenyDataInTransit @hidden
        developer info: "Only trigger deny on Data in transit on client connections."
        ->  (networks  \/ inNetworks  \/ diodeInNetworks).transitData.attemptDenyDataInTransitFromConnectionRule

    }

}

associations {
  System           [hostSystem]        0..1 <-- SysExecution          --> *   [sysExecutedApps]        Application
      developer info: "System is the hardware on which Applications are running. The host system is not mandatory to be specified but if it is, it adds on the model!"
  Application      [hostApp]           0..1 <-- AppExecution          --> *   [appExecutedApps]        Application
      developer info: "Application 1 runs application 2 runs application 3! (Where application 1 can be an OS, application 2 is a VM and application 3 is app running on the VM."
  IDPS             [protectorIDPSs]       * <-- AppProtection         --> *   [protectedApps]          Application
      developer info: "IDPSs can provide protection to other applications."
  SoftwareProduct  [appSoftProduct]    0..1 <-- AppSoftwareProduct    --> *   [softApplications]       Application
      user info: "An application can be associated with a software product that has some specific characteristics such as specific Vulnerabilities."
  // ### Networking associations
  PhysicalZone     [physicalZone]      0..1 <-- ZoneInclusion         --> *   [systems]                System
      developer info: "Access on PhysicalZone will give physicalAccess on the deployed Systems but access on a System does not always provide access to the physical zone (e.g. iLOs)."
  RoutingFirewall  [routingFirewalls]  0..1 <-- ConnectionRule        --> *   [connectionRules]        ConnectionRule
      user info: "A routing firewall has routing or firewall rules specified by connections between networks or applications respectively."
  RoutingFirewall  [managedRoutingFw]     * <-- ManagedBy             --> 0..1[managerApp]             Application
      user info: "A routing firewall can have an admin/manager interface (application) that is accesible from a network location."
  Network          [networks]             * <-- NetworkExposure       --> *   [applications]           Application
      user info: "An application can communicate / be exposed on a network."
      modeler info: "This is DEPRECATED and should only be used by fully aware modelers."
      developer info: "This can equivalently be modeled using a ConnectionRule but this direct approach should be prefered in the case where the application is located in the same network as the host on which it is running."
  Network          [clientAccessNetworks] * <-- ClientAccess          --> *   [clientApplications]     Application
      user info: "A client application can communicate over a network."
  Application      [applications]         * <-- ApplicationConnection --> *   [appConnections]         ConnectionRule
      user info: "An application can communicate over one or more (mesh type) bidirectional connections."
      modeler info: "ConnectionRules associated with Applications are practically expressing a traffic flow."
  Application      [inApplications]       * <-- InApplicationConnection --> * [ingoingAppConnections]  ConnectionRule
      user info: "Two or more applications can also be inter-connected via a uni-directional connection. In means that this is the server side application, awaiting incoming connections."
  Application      [outApplications]      * <-- OutApplicationConnection --> *[outgoingAppConnections] ConnectionRule
      user info: "Two or more applications can also be inter-connected via a uni-directional connection. Out means that this is the client side application initiating connections."
  Network          [networks]             * <-- NetworkConnection     --> *   [netConnections]         ConnectionRule
      user info: "Two or more networks can also be inter-connected via a bidirectional connection."
  Network          [inNetworks]           * <-- InNetworkConnection   --> *   [ingoingNetConnections]  ConnectionRule
      user info: "Two or more networks can also be inter-connected via a uni-directional connection. In means that ingoing traffic to the network is allowed."
  Network          [outNetworks]          * <-- OutNetworkConnection  --> *   [outgoingNetConnections] ConnectionRule
      user info: "Two or more networks can also be inter-connected via a uni-directional connection. Out means that outgoing traffic from the network is allowed."
  Network          [diodeInNetworks]      * <-- DiodeInNetworkConnection --> * [diodeIngoingNetConnections] ConnectionRule
      user info: "Two or more networks can also be inter-connected via a uni-directional connection that acts like a diode. That means that no repsonses can come back after connection initiation."
  // ### Data related associations
  Data             [containingData]       * <-- DataContainment       --> *   [containedData]          Data
      user info: "Data can be contained inside other data."
  Data             [containedData]        * <-- AppContainment        --> *   [containingApp]          Application
      user info: "An application should be able to contain some data."
  Data             [sentData]             * <-- SendData              --> *   [senderApp]              Application
      user info: "An application can also send some data that are supposed to be transfered over a connection. This expresses an active connection."
  Data             [receivedData]         * <-- ReceiveData           --> *   [receiverApp]            Application
      user info: "An application can also receive some data that are supposed to be transfered over a connection. This expresses an active connection."
  Data             [transitData]          * <-- DataInTransit         --> *   [transitNetwork]         Network
      user info: "A network can also contain some data that are supposed to be network-wide available."
  System           [system]            0..1 <-- DataHosting           --> *   [sysData]                Data
      user info: "A system can host data."
  Data             [containerData]        * <-- InfoContainment       --> *   [information]            Information
      user info: "Data can contain information, as for example credentials."
  Data             [dataReplicas]          * <-- Replica                --> * [replicatedInformation]  Information
      user info: "Information can be replicated across multiple data assets that offer redundancy."
  Data             [encryptedData]        * <-- EncryptionCredentials --> 0..1 [encryptCreds]          Credentials
      user info: "Encrypted data can be associated with the relevant encryption credentials."
  Data             [signedData]           * <-- SigningCredentials    --> 0..1[signingCreds]           Credentials
      user info: "Signed data can be associated with the relevant signing credentials."
  Credentials      [hashes]               * <-- HashedCredentials     --> 0..1 [origCreds]             Credentials
      user info: "Credentials can be associated with their hashed counterparts. Multiple hashes can be generated for the same Credentials, but a hash is unique to one set of Credentials."
  Credentials      [credentials]          * <-- ConditionalAuthentication --> *[requiredFactors]        Credentials
      user info: "Credentials can be associated with other Credentials to depict conditional authentication procedures, such as multi-factor authentication."
  Data             [originData]        0..1 <-- Origin                --> 0..1[originSoftwareProduct]  SoftwareProduct
      user info: "Any SoftwareProduct can be associated with Origin Data that represents the source from which this software was obtained." 
  // ### Access Control happens below
  Identity         [identities]           * <-- IdentityCredentials   --> *   [credentials]            Credentials
  Identity         [userIds]              * <-- UserAssignedIdentities--> *   [users]                  User
  Identity         [parentId]             * <-- CanAssume             --> *   [childId]                Identity
      user info: "Starting from a parent Identity, the child Identities can be assumed due to inheritance."
  Group            [memberOf]             * <-- MemberOf              --> *   [groupIds]               Identity
  Group            [parentGroup]          * <-- MemberOf              --> *   [childGroups]            Group
  // First on system level
  Identity         [highPrivSysIds]       * <-- HighPrivilegeAccess   --> *   [highPrivManagedSystems] System
      user info: "High privilege access on a System results in the compromise of all the privileges assigned to that system."
  Identity         [lowPrivSysIds]        * <-- LowPrivilegeAccess    --> *   [lowPrivManagedSystems]  System
      user info: "Low privilege access on a System provides individual identity access on the system."
  // And the same for Groups
  Group            [highPrivSysGroups]    * <-- HighPrivilegeAccess   --> *   [highPrivManagedSystems] System
      user info: "High privilege access on a System results in the compromise of all the privileges assigned to that system."
  Group            [lowPrivSysGroups]     * <-- LowPrivilegeAccess    --> *   [lowPrivManagedSystems]  System
      user info: "Low privilege access on a System provides individual identity access on the system."
  // Then, Access Control on application level
  Identity         [executionPrivIds]     * <-- ExecutionPrivilegeAccess  --> *   [execPrivApps]       Application
      user info: "Every application executes on a system with privileges of a specified identity on the system. If the application is compromised then the privileges should be compromised."
  Identity         [highPrivAppIds]       * <-- HighPrivilegeApplicationAccess --> * [highPrivApps]    Application
      user info: "High privilege application access on an Application results in the (full) access/compromise of the application and all the child applications."
  Identity         [lowPrivAppIds]        * <-- LowPrivilegeApplicationAccess  --> * [lowPrivApps]     Application
      user info: "Low privilege application access on an Application allows only the local interaction with the application and all the specified privileges."
  // And the same for Groups
  Group           [executionPrivGroups]   * <-- ExecutionPrivilegeAccess  --> *   [execPrivApps]       Application
      user info: "An application can execute on a system with privileges of a specified group. If the application is compromised then the group privileges should be compromised."
  Group           [highPrivAppGroups]     * <-- HighPrivilegeApplicationAccess --> * [highPrivApps]    Application
      user info: "High privilege application access on an Application results in the compromise of all the child applications."
  Group           [lowPrivAppGroups]      * <-- LowPrivilegeApplicationAccess  --> * [lowPrivApps]     Application
      user info: "Low privilege application access on an Application allows only the local interaction with the application."
  // Finally, Access control on data
  Identity         [readingIds]           * <-- ReadPrivileges        --> *   [readPrivData]           Data
  Identity         [writingIds]           * <-- WritePrivileges       --> *   [writePrivData]          Data
  Identity         [deletingIds]          * <-- DeletePrivileges      --> *   [deletePrivData]         Data
  // And again for Groups
  Group            [readingGroups]        * <-- ReadPrivileges        --> *   [readPrivData]           Data
  Group            [writingGroups]        * <-- WritePrivileges       --> *   [writePrivData]          Data
  Group            [deletingGroups]       * <-- DeletePrivileges      --> *   [deletePrivData]         Data
  // Associations for the Privileges asset
  Identity         [privilegeIdentities]  * <-- HasPrivileges         --> *   [identityPrivileges]     Privileges
      user info: "Any Identity can be associated with a Privileges asset that groups privileges for Applications and Data." 
  Privileges       [executionPrivAppPriv] * <-- ExecutionPrivilegeAccess  --> *   [execPrivApps]       Application
  Privileges       [highPrivAppPriv]      * <-- HighPrivilegeApplicationAccess --> * [highPrivApps]    Application
  Privileges       [lowPrivAppPriv]       * <-- LowPrivilegeApplicationAccess  --> * [lowPrivApps]     Application
  Privileges       [readingPriv]          * <-- ReadPrivileges        --> *   [readPrivData]           Data
  Privileges       [writingPriv]          * <-- WritePrivileges       --> *   [writePrivData]          Data
  Privileges       [deletingPriv]         * <-- DeletePrivileges      --> *   [deletePrivData]         Data
}
